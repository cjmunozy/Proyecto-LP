Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ASSIGN
    BREAK
    COLON
    COMMA
    CONCAT
    DIVIDEASSIGN
    DO
    DOT
    DOUBLECOLON
    ELSE
    ELSEIF
    END
    EQUALS
    FALSE
    FOR
    FUNCTION
    GOTO
    GREATER
    GREATEREQUALS
    IDENTIFIER
    IF
    IN
    LBRACE
    LBRACKET
    LEN
    LOCAL
    LOWER
    LOWEREQUALS
    MINUSASSIGN
    MOD
    MODASSIGN
    NEQUALS
    NIL
    NOT
    OR
    PLUSASSIGN
    POWERASSIGN
    RBRACE
    RBRACKET
    REPEAT
    RETURN
    SEMICOLON
    THEN
    TIMESASSIGN
    TRUE
    UNTIL
    WHILE

Grammar

Rule 0     S' -> start
Rule 1     start -> expression
Rule 2     start -> input
Rule 3     start -> print
Rule 4     expression -> expression PLUS term
Rule 5     expression -> expression MINUS term
Rule 6     expression -> term
Rule 7     term -> term TIMES factor
Rule 8     term -> term DIVIDE factor
Rule 9     factor -> factor POWER factor
Rule 10    term -> factor
Rule 11    factor -> INTEGER
Rule 12    factor -> FLOAT
Rule 13    factor -> LPAREN expression RPAREN
Rule 14    print -> PRINT factor
Rule 15    print -> PRINT LPAREN STRING RPAREN
Rule 16    input -> INPUT LPAREN RPAREN

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 
BREAK                : 
COLON                : 
COMMA                : 
CONCAT               : 
DIVIDE               : 8
DIVIDEASSIGN         : 
DO                   : 
DOT                  : 
DOUBLECOLON          : 
ELSE                 : 
ELSEIF               : 
END                  : 
EQUALS               : 
FALSE                : 
FLOAT                : 12
FOR                  : 
FUNCTION             : 
GOTO                 : 
GREATER              : 
GREATEREQUALS        : 
IDENTIFIER           : 
IF                   : 
IN                   : 
INPUT                : 16
INTEGER              : 11
LBRACE               : 
LBRACKET             : 
LEN                  : 
LOCAL                : 
LOWER                : 
LOWEREQUALS          : 
LPAREN               : 13 15 16
MINUS                : 5
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NEQUALS              : 
NIL                  : 
NOT                  : 
OR                   : 
PLUS                 : 4
PLUSASSIGN           : 
POWER                : 9
POWERASSIGN          : 
PRINT                : 14 15
RBRACE               : 
RBRACKET             : 
REPEAT               : 
RETURN               : 
RPAREN               : 13 15 16
SEMICOLON            : 
STRING               : 15
THEN                 : 
TIMES                : 7
TIMESASSIGN          : 
TRUE                 : 
UNTIL                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

expression           : 1 4 5 13
factor               : 7 8 9 9 10 14
input                : 2
print                : 3
start                : 0
term                 : 4 5 6 7 8

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . expression
    (2) start -> . input
    (3) start -> . print
    (4) expression -> . expression PLUS term
    (5) expression -> . expression MINUS term
    (6) expression -> . term
    (16) input -> . INPUT LPAREN RPAREN
    (14) print -> . PRINT factor
    (15) print -> . PRINT LPAREN STRING RPAREN
    (7) term -> . term TIMES factor
    (8) term -> . term DIVIDE factor
    (10) term -> . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INPUT           shift and go to state 6
    PRINT           shift and go to state 8
    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    start                          shift and go to state 1
    expression                     shift and go to state 2
    input                          shift and go to state 3
    print                          shift and go to state 4
    term                           shift and go to state 5
    factor                         shift and go to state 9

state 1

    (0) S' -> start .



state 2

    (1) start -> expression .
    (4) expression -> expression . PLUS term
    (5) expression -> expression . MINUS term

    $end            reduce using rule 1 (start -> expression .)
    PLUS            shift and go to state 12
    MINUS           shift and go to state 13


state 3

    (2) start -> input .

    $end            reduce using rule 2 (start -> input .)


state 4

    (3) start -> print .

    $end            reduce using rule 3 (start -> print .)


state 5

    (6) expression -> term .
    (7) term -> term . TIMES factor
    (8) term -> term . DIVIDE factor

    PLUS            reduce using rule 6 (expression -> term .)
    MINUS           reduce using rule 6 (expression -> term .)
    $end            reduce using rule 6 (expression -> term .)
    RPAREN          reduce using rule 6 (expression -> term .)
    TIMES           shift and go to state 14
    DIVIDE          shift and go to state 15


state 6

    (16) input -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 16


state 7

    (13) factor -> LPAREN . expression RPAREN
    (4) expression -> . expression PLUS term
    (5) expression -> . expression MINUS term
    (6) expression -> . term
    (7) term -> . term TIMES factor
    (8) term -> . term DIVIDE factor
    (10) term -> . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    expression                     shift and go to state 17
    term                           shift and go to state 5
    factor                         shift and go to state 9

state 8

    (14) print -> PRINT . factor
    (15) print -> PRINT . LPAREN STRING RPAREN
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    LPAREN          shift and go to state 19
    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11

    factor                         shift and go to state 18

state 9

    (10) term -> factor .
    (9) factor -> factor . POWER factor

    TIMES           reduce using rule 10 (term -> factor .)
    DIVIDE          reduce using rule 10 (term -> factor .)
    PLUS            reduce using rule 10 (term -> factor .)
    MINUS           reduce using rule 10 (term -> factor .)
    $end            reduce using rule 10 (term -> factor .)
    RPAREN          reduce using rule 10 (term -> factor .)
    POWER           shift and go to state 20


state 10

    (11) factor -> INTEGER .

    POWER           reduce using rule 11 (factor -> INTEGER .)
    TIMES           reduce using rule 11 (factor -> INTEGER .)
    DIVIDE          reduce using rule 11 (factor -> INTEGER .)
    PLUS            reduce using rule 11 (factor -> INTEGER .)
    MINUS           reduce using rule 11 (factor -> INTEGER .)
    $end            reduce using rule 11 (factor -> INTEGER .)
    RPAREN          reduce using rule 11 (factor -> INTEGER .)


state 11

    (12) factor -> FLOAT .

    POWER           reduce using rule 12 (factor -> FLOAT .)
    TIMES           reduce using rule 12 (factor -> FLOAT .)
    DIVIDE          reduce using rule 12 (factor -> FLOAT .)
    PLUS            reduce using rule 12 (factor -> FLOAT .)
    MINUS           reduce using rule 12 (factor -> FLOAT .)
    $end            reduce using rule 12 (factor -> FLOAT .)
    RPAREN          reduce using rule 12 (factor -> FLOAT .)


state 12

    (4) expression -> expression PLUS . term
    (7) term -> . term TIMES factor
    (8) term -> . term DIVIDE factor
    (10) term -> . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    term                           shift and go to state 21
    factor                         shift and go to state 9

state 13

    (5) expression -> expression MINUS . term
    (7) term -> . term TIMES factor
    (8) term -> . term DIVIDE factor
    (10) term -> . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    term                           shift and go to state 22
    factor                         shift and go to state 9

state 14

    (7) term -> term TIMES . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    factor                         shift and go to state 23

state 15

    (8) term -> term DIVIDE . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    factor                         shift and go to state 24

state 16

    (16) input -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 25


state 17

    (13) factor -> LPAREN expression . RPAREN
    (4) expression -> expression . PLUS term
    (5) expression -> expression . MINUS term

    RPAREN          shift and go to state 26
    PLUS            shift and go to state 12
    MINUS           shift and go to state 13


state 18

    (14) print -> PRINT factor .
    (9) factor -> factor . POWER factor

    $end            reduce using rule 14 (print -> PRINT factor .)
    POWER           shift and go to state 20


state 19

    (15) print -> PRINT LPAREN . STRING RPAREN
    (13) factor -> LPAREN . expression RPAREN
    (4) expression -> . expression PLUS term
    (5) expression -> . expression MINUS term
    (6) expression -> . term
    (7) term -> . term TIMES factor
    (8) term -> . term DIVIDE factor
    (10) term -> . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 27
    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    expression                     shift and go to state 17
    term                           shift and go to state 5
    factor                         shift and go to state 9

state 20

    (9) factor -> factor POWER . factor
    (9) factor -> . factor POWER factor
    (11) factor -> . INTEGER
    (12) factor -> . FLOAT
    (13) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 10
    FLOAT           shift and go to state 11
    LPAREN          shift and go to state 7

    factor                         shift and go to state 28

state 21

    (4) expression -> expression PLUS term .
    (7) term -> term . TIMES factor
    (8) term -> term . DIVIDE factor

    PLUS            reduce using rule 4 (expression -> expression PLUS term .)
    MINUS           reduce using rule 4 (expression -> expression PLUS term .)
    $end            reduce using rule 4 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 4 (expression -> expression PLUS term .)
    TIMES           shift and go to state 14
    DIVIDE          shift and go to state 15


state 22

    (5) expression -> expression MINUS term .
    (7) term -> term . TIMES factor
    (8) term -> term . DIVIDE factor

    PLUS            reduce using rule 5 (expression -> expression MINUS term .)
    MINUS           reduce using rule 5 (expression -> expression MINUS term .)
    $end            reduce using rule 5 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 5 (expression -> expression MINUS term .)
    TIMES           shift and go to state 14
    DIVIDE          shift and go to state 15


state 23

    (7) term -> term TIMES factor .
    (9) factor -> factor . POWER factor

    TIMES           reduce using rule 7 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 7 (term -> term TIMES factor .)
    PLUS            reduce using rule 7 (term -> term TIMES factor .)
    MINUS           reduce using rule 7 (term -> term TIMES factor .)
    $end            reduce using rule 7 (term -> term TIMES factor .)
    RPAREN          reduce using rule 7 (term -> term TIMES factor .)
    POWER           shift and go to state 20


state 24

    (8) term -> term DIVIDE factor .
    (9) factor -> factor . POWER factor

    TIMES           reduce using rule 8 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 8 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 8 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 8 (term -> term DIVIDE factor .)
    $end            reduce using rule 8 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 8 (term -> term DIVIDE factor .)
    POWER           shift and go to state 20


state 25

    (16) input -> INPUT LPAREN RPAREN .

    $end            reduce using rule 16 (input -> INPUT LPAREN RPAREN .)


state 26

    (13) factor -> LPAREN expression RPAREN .

    POWER           reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 13 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 13 (factor -> LPAREN expression RPAREN .)


state 27

    (15) print -> PRINT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 29


state 28

    (9) factor -> factor POWER factor .
    (9) factor -> factor . POWER factor

  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 9 (factor -> factor POWER factor .)
    DIVIDE          reduce using rule 9 (factor -> factor POWER factor .)
    PLUS            reduce using rule 9 (factor -> factor POWER factor .)
    MINUS           reduce using rule 9 (factor -> factor POWER factor .)
    $end            reduce using rule 9 (factor -> factor POWER factor .)
    RPAREN          reduce using rule 9 (factor -> factor POWER factor .)
    POWER           shift and go to state 20

  ! POWER           [ reduce using rule 9 (factor -> factor POWER factor .) ]


state 29

    (15) print -> PRINT LPAREN STRING RPAREN .

    $end            reduce using rule 15 (print -> PRINT LPAREN STRING RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for POWER in state 28 resolved as shift
