Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    CONCAT
    DIVIDEASSIGN
    EQUALS
    FALSE
    GREATER
    GREATEREQUALS
    LEN
    LOWER
    LOWEREQUALS
    MINUSASSIGN
    MOD
    MODASSIGN
    NEQUALS
    NIL
    NOT
    OR
    PLUSASSIGN
    POWERASSIGN
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> start
Rule 1     start -> chunk
Rule 2     chunk -> block
Rule 3     block -> stat_list retstat_opt
Rule 4     stat_list -> stat_list stat
Rule 5     stat_list -> empty
Rule 6     retstat_opt -> retstat
Rule 7     retstat_opt -> empty
Rule 8     stat -> SEMICOLON
Rule 9     stat -> varlist ASSIGN explist
Rule 10    stat -> functioncall
Rule 11    stat -> BREAK
Rule 12    stat -> GOTO IDENTIFIER
Rule 13    stat -> DO block END
Rule 14    stat -> WHILE expression DO block END
Rule 15    stat -> REPEAT block UNTIL expression
Rule 16    stat -> IF expression THEN block elseif_blocks else_block END
Rule 17    elseif_blocks -> ELSEIF expression THEN block
Rule 18    elseif_blocks -> elseif_blocks ELSEIF expression THEN block
Rule 19    elseif_blocks -> empty
Rule 20    else_block -> ELSE block
Rule 21    else_block -> empty
Rule 22    stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
Rule 23    stat -> FOR namelist IN explist DO block END
Rule 24    stat -> FUNCTION funcname funcbody
Rule 25    stat -> LOCAL FUNCTION IDENTIFIER funcbody
Rule 26    empty -> <empty>
Rule 27    retstat -> RETURN explist SEMICOLON
Rule 28    retstat -> RETURN explist
Rule 29    retstat -> RETURN SEMICOLON
Rule 30    retstat -> RETURN
Rule 31    stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON
Rule 32    funcname -> IDENTIFIER funcname_tail method_opt
Rule 33    funcname_tail -> funcname_tail DOT IDENTIFIER
Rule 34    funcname_tail -> empty
Rule 35    method_opt -> COLON IDENTIFIER
Rule 36    method_opt -> empty
Rule 37    varlist -> var
Rule 38    varlist -> varlist COMMA var
Rule 39    var -> IDENTIFIER
Rule 40    var -> prefixexp LBRACKET expression RBRACKET
Rule 41    var -> prefixexp DOT IDENTIFIER
Rule 42    namelist -> IDENTIFIER
Rule 43    namelist -> namelist COMMA IDENTIFIER
Rule 44    explist -> expression
Rule 45    explist -> explist COMMA expression
Rule 46    prefixexp -> var
Rule 47    prefixexp -> functioncall
Rule 48    prefixexp -> LPAREN expression RPAREN
Rule 49    functioncall -> prefixexp args
Rule 50    functioncall -> prefixexp COLON IDENTIFIER args
Rule 51    args -> LPAREN RPAREN
Rule 52    args -> LPAREN explist RPAREN
Rule 53    args -> STRING
Rule 54    args -> tableconstructor
Rule 55    expression -> FUNCTION funcbody
Rule 56    funcbody -> LPAREN RPAREN block END
Rule 57    funcbody -> LPAREN parlist RPAREN block END
Rule 58    parlist -> namelist vararg_tail
Rule 59    parlist -> VARARG
Rule 60    vararg_tail -> COMMA VARARG
Rule 61    vararg_tail -> empty
Rule 62    tableconstructor -> LBRACE RBRACE
Rule 63    tableconstructor -> LBRACE fieldlist RBRACE
Rule 64    fieldlist -> field fieldsep_tail
Rule 65    fieldsep_tail -> fieldsep fieldfield_tail_opt
Rule 66    fieldsep_tail -> empty
Rule 67    fieldfield_tail_opt -> fieldlist
Rule 68    fieldfield_tail_opt -> empty
Rule 69    field -> LBRACKET expression RBRACKET ASSIGN expression
Rule 70    field -> IDENTIFIER ASSIGN expression
Rule 71    field -> expression
Rule 72    fieldsep -> COMMA
Rule 73    fieldsep -> SEMICOLON
Rule 74    statement -> input
Rule 75    statement -> print
Rule 76    expression -> expression PLUS term
Rule 77    expression -> expression MINUS term
Rule 78    term -> term TIMES factor
Rule 79    term -> term DIVIDE factor
Rule 80    term -> term POWER factor
Rule 81    expression -> term
Rule 82    term -> factor
Rule 83    factor -> INTEGER
Rule 84    factor -> FLOAT
Rule 85    factor -> LPAREN expression RPAREN
Rule 86    print -> PRINT LPAREN expression RPAREN
Rule 87    print -> PRINT LPAREN STRING RPAREN
Rule 88    input -> INPUT LPAREN RPAREN

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 9 22 69 70
BREAK                : 11
COLON                : 35 50
COMMA                : 22 38 43 45 60 72
CONCAT               : 
DIVIDE               : 79
DIVIDEASSIGN         : 
DO                   : 13 14 22 23
DOT                  : 33 41
DOUBLECOLON          : 31 31
ELSE                 : 20
ELSEIF               : 17 18
END                  : 13 14 16 22 23 56 57
EQUALS               : 
FALSE                : 
FLOAT                : 84
FOR                  : 22 23
FUNCTION             : 24 25 55
GOTO                 : 12
GREATER              : 
GREATEREQUALS        : 
IDENTIFIER           : 12 22 25 31 32 33 35 39 41 42 43 50 70
IF                   : 16
IN                   : 23
INPUT                : 88
INTEGER              : 83
LBRACE               : 62 63
LBRACKET             : 40 69
LEN                  : 
LOCAL                : 25
LOWER                : 
LOWEREQUALS          : 
LPAREN               : 48 51 52 56 57 85 86 87 88
MINUS                : 77
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NEQUALS              : 
NIL                  : 
NOT                  : 
OR                   : 
PLUS                 : 76
PLUSASSIGN           : 
POWER                : 80
POWERASSIGN          : 
PRINT                : 86 87
RBRACE               : 62 63
RBRACKET             : 40 69
REPEAT               : 15
RETURN               : 27 28 29 30
RPAREN               : 48 51 52 56 57 85 86 87 88
SEMICOLON            : 8 27 29 73
STRING               : 53 87
THEN                 : 16 17 18
TIMES                : 78
TIMESASSIGN          : 
TRUE                 : 
UNTIL                : 15
VARARG               : 59 60
WHILE                : 14
error                : 

Nonterminals, with rules where they appear

args                 : 49 50
block                : 2 13 14 15 16 17 18 20 22 23 56 57
chunk                : 1
else_block           : 16
elseif_blocks        : 16 18
empty                : 5 7 19 21 34 36 61 66 68
explist              : 9 23 27 28 45 52
expression           : 14 15 16 17 18 22 22 40 44 45 48 69 69 70 71 76 77 85 86
factor               : 78 79 80 82
field                : 64
fieldfield_tail_opt  : 65
fieldlist            : 63 67
fieldsep             : 65
fieldsep_tail        : 64
funcbody             : 24 25 55
funcname             : 24
funcname_tail        : 32 33
functioncall         : 10 47
input                : 74
method_opt           : 32
namelist             : 23 43 58
parlist              : 57
prefixexp            : 40 41 49 50
print                : 75
retstat              : 6
retstat_opt          : 3
start                : 0
stat                 : 4
stat_list            : 3 4
statement            : 
tableconstructor     : 54
term                 : 76 77 78 79 80 81
var                  : 37 38 46
vararg_tail          : 58
varlist              : 9 38

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . chunk
    (2) chunk -> . block
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    $end            reduce using rule 26 (empty -> .)

    start                          shift and go to state 1
    chunk                          shift and go to state 2
    block                          shift and go to state 3
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> start .



state 2

    (1) start -> chunk .

    $end            reduce using rule 1 (start -> chunk .)


state 3

    (2) chunk -> block .

    $end            reduce using rule 2 (chunk -> block .)


state 4

    (3) block -> stat_list . retstat_opt
    (4) stat_list -> stat_list . stat
    (6) retstat_opt -> . retstat
    (7) retstat_opt -> . empty
    (8) stat -> . SEMICOLON
    (9) stat -> . varlist ASSIGN explist
    (10) stat -> . functioncall
    (11) stat -> . BREAK
    (12) stat -> . GOTO IDENTIFIER
    (13) stat -> . DO block END
    (14) stat -> . WHILE expression DO block END
    (15) stat -> . REPEAT block UNTIL expression
    (16) stat -> . IF expression THEN block elseif_blocks else_block END
    (22) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (23) stat -> . FOR namelist IN explist DO block END
    (24) stat -> . FUNCTION funcname funcbody
    (25) stat -> . LOCAL FUNCTION IDENTIFIER funcbody
    (31) stat -> . DOUBLECOLON IDENTIFIER DOUBLECOLON
    (27) retstat -> . RETURN explist SEMICOLON
    (28) retstat -> . RETURN explist
    (29) retstat -> . RETURN SEMICOLON
    (30) retstat -> . RETURN
    (26) empty -> .
    (37) varlist -> . var
    (38) varlist -> . varlist COMMA var
    (49) functioncall -> . prefixexp args
    (50) functioncall -> . prefixexp COLON IDENTIFIER args
    (39) var -> . IDENTIFIER
    (40) var -> . prefixexp LBRACKET expression RBRACKET
    (41) var -> . prefixexp DOT IDENTIFIER
    (46) prefixexp -> . var
    (47) prefixexp -> . functioncall
    (48) prefixexp -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 10
    BREAK           shift and go to state 13
    GOTO            shift and go to state 14
    DO              shift and go to state 16
    WHILE           shift and go to state 17
    REPEAT          shift and go to state 18
    IF              shift and go to state 19
    FOR             shift and go to state 20
    FUNCTION        shift and go to state 21
    LOCAL           shift and go to state 22
    DOUBLECOLON     shift and go to state 23
    RETURN          shift and go to state 24
    $end            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)
    UNTIL           reduce using rule 26 (empty -> .)
    ELSEIF          reduce using rule 26 (empty -> .)
    ELSE            reduce using rule 26 (empty -> .)
    IDENTIFIER      shift and go to state 15
    LPAREN          shift and go to state 27

    retstat_opt                    shift and go to state 6
    stat                           shift and go to state 7
    retstat                        shift and go to state 8
    empty                          shift and go to state 9
    varlist                        shift and go to state 11
    functioncall                   shift and go to state 12
    var                            shift and go to state 25
    prefixexp                      shift and go to state 26

state 5

    (5) stat_list -> empty .

    SEMICOLON       reduce using rule 5 (stat_list -> empty .)
    BREAK           reduce using rule 5 (stat_list -> empty .)
    GOTO            reduce using rule 5 (stat_list -> empty .)
    DO              reduce using rule 5 (stat_list -> empty .)
    WHILE           reduce using rule 5 (stat_list -> empty .)
    REPEAT          reduce using rule 5 (stat_list -> empty .)
    IF              reduce using rule 5 (stat_list -> empty .)
    FOR             reduce using rule 5 (stat_list -> empty .)
    FUNCTION        reduce using rule 5 (stat_list -> empty .)
    LOCAL           reduce using rule 5 (stat_list -> empty .)
    DOUBLECOLON     reduce using rule 5 (stat_list -> empty .)
    RETURN          reduce using rule 5 (stat_list -> empty .)
    IDENTIFIER      reduce using rule 5 (stat_list -> empty .)
    LPAREN          reduce using rule 5 (stat_list -> empty .)
    $end            reduce using rule 5 (stat_list -> empty .)
    END             reduce using rule 5 (stat_list -> empty .)
    UNTIL           reduce using rule 5 (stat_list -> empty .)
    ELSEIF          reduce using rule 5 (stat_list -> empty .)
    ELSE            reduce using rule 5 (stat_list -> empty .)


state 6

    (3) block -> stat_list retstat_opt .

    $end            reduce using rule 3 (block -> stat_list retstat_opt .)
    END             reduce using rule 3 (block -> stat_list retstat_opt .)
    UNTIL           reduce using rule 3 (block -> stat_list retstat_opt .)
    ELSEIF          reduce using rule 3 (block -> stat_list retstat_opt .)
    ELSE            reduce using rule 3 (block -> stat_list retstat_opt .)


state 7

    (4) stat_list -> stat_list stat .

    SEMICOLON       reduce using rule 4 (stat_list -> stat_list stat .)
    BREAK           reduce using rule 4 (stat_list -> stat_list stat .)
    GOTO            reduce using rule 4 (stat_list -> stat_list stat .)
    DO              reduce using rule 4 (stat_list -> stat_list stat .)
    WHILE           reduce using rule 4 (stat_list -> stat_list stat .)
    REPEAT          reduce using rule 4 (stat_list -> stat_list stat .)
    IF              reduce using rule 4 (stat_list -> stat_list stat .)
    FOR             reduce using rule 4 (stat_list -> stat_list stat .)
    FUNCTION        reduce using rule 4 (stat_list -> stat_list stat .)
    LOCAL           reduce using rule 4 (stat_list -> stat_list stat .)
    DOUBLECOLON     reduce using rule 4 (stat_list -> stat_list stat .)
    RETURN          reduce using rule 4 (stat_list -> stat_list stat .)
    IDENTIFIER      reduce using rule 4 (stat_list -> stat_list stat .)
    LPAREN          reduce using rule 4 (stat_list -> stat_list stat .)
    $end            reduce using rule 4 (stat_list -> stat_list stat .)
    END             reduce using rule 4 (stat_list -> stat_list stat .)
    UNTIL           reduce using rule 4 (stat_list -> stat_list stat .)
    ELSEIF          reduce using rule 4 (stat_list -> stat_list stat .)
    ELSE            reduce using rule 4 (stat_list -> stat_list stat .)


state 8

    (6) retstat_opt -> retstat .

    $end            reduce using rule 6 (retstat_opt -> retstat .)
    END             reduce using rule 6 (retstat_opt -> retstat .)
    UNTIL           reduce using rule 6 (retstat_opt -> retstat .)
    ELSEIF          reduce using rule 6 (retstat_opt -> retstat .)
    ELSE            reduce using rule 6 (retstat_opt -> retstat .)


state 9

    (7) retstat_opt -> empty .

    $end            reduce using rule 7 (retstat_opt -> empty .)
    END             reduce using rule 7 (retstat_opt -> empty .)
    UNTIL           reduce using rule 7 (retstat_opt -> empty .)
    ELSEIF          reduce using rule 7 (retstat_opt -> empty .)
    ELSE            reduce using rule 7 (retstat_opt -> empty .)


state 10

    (8) stat -> SEMICOLON .

    SEMICOLON       reduce using rule 8 (stat -> SEMICOLON .)
    BREAK           reduce using rule 8 (stat -> SEMICOLON .)
    GOTO            reduce using rule 8 (stat -> SEMICOLON .)
    DO              reduce using rule 8 (stat -> SEMICOLON .)
    WHILE           reduce using rule 8 (stat -> SEMICOLON .)
    REPEAT          reduce using rule 8 (stat -> SEMICOLON .)
    IF              reduce using rule 8 (stat -> SEMICOLON .)
    FOR             reduce using rule 8 (stat -> SEMICOLON .)
    FUNCTION        reduce using rule 8 (stat -> SEMICOLON .)
    LOCAL           reduce using rule 8 (stat -> SEMICOLON .)
    DOUBLECOLON     reduce using rule 8 (stat -> SEMICOLON .)
    RETURN          reduce using rule 8 (stat -> SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (stat -> SEMICOLON .)
    LPAREN          reduce using rule 8 (stat -> SEMICOLON .)
    $end            reduce using rule 8 (stat -> SEMICOLON .)
    END             reduce using rule 8 (stat -> SEMICOLON .)
    UNTIL           reduce using rule 8 (stat -> SEMICOLON .)
    ELSEIF          reduce using rule 8 (stat -> SEMICOLON .)
    ELSE            reduce using rule 8 (stat -> SEMICOLON .)


state 11

    (9) stat -> varlist . ASSIGN explist
    (38) varlist -> varlist . COMMA var

    ASSIGN          shift and go to state 28
    COMMA           shift and go to state 29


state 12

    (10) stat -> functioncall .
    (47) prefixexp -> functioncall .

  ! reduce/reduce conflict for LPAREN resolved using rule 10 (stat -> functioncall .)
    SEMICOLON       reduce using rule 10 (stat -> functioncall .)
    BREAK           reduce using rule 10 (stat -> functioncall .)
    GOTO            reduce using rule 10 (stat -> functioncall .)
    DO              reduce using rule 10 (stat -> functioncall .)
    WHILE           reduce using rule 10 (stat -> functioncall .)
    REPEAT          reduce using rule 10 (stat -> functioncall .)
    IF              reduce using rule 10 (stat -> functioncall .)
    FOR             reduce using rule 10 (stat -> functioncall .)
    FUNCTION        reduce using rule 10 (stat -> functioncall .)
    LOCAL           reduce using rule 10 (stat -> functioncall .)
    DOUBLECOLON     reduce using rule 10 (stat -> functioncall .)
    RETURN          reduce using rule 10 (stat -> functioncall .)
    IDENTIFIER      reduce using rule 10 (stat -> functioncall .)
    LPAREN          reduce using rule 10 (stat -> functioncall .)
    $end            reduce using rule 10 (stat -> functioncall .)
    END             reduce using rule 10 (stat -> functioncall .)
    UNTIL           reduce using rule 10 (stat -> functioncall .)
    ELSEIF          reduce using rule 10 (stat -> functioncall .)
    ELSE            reduce using rule 10 (stat -> functioncall .)
    COLON           reduce using rule 47 (prefixexp -> functioncall .)
    LBRACKET        reduce using rule 47 (prefixexp -> functioncall .)
    DOT             reduce using rule 47 (prefixexp -> functioncall .)
    STRING          reduce using rule 47 (prefixexp -> functioncall .)
    LBRACE          reduce using rule 47 (prefixexp -> functioncall .)

  ! LPAREN          [ reduce using rule 47 (prefixexp -> functioncall .) ]


state 13

    (11) stat -> BREAK .

    SEMICOLON       reduce using rule 11 (stat -> BREAK .)
    BREAK           reduce using rule 11 (stat -> BREAK .)
    GOTO            reduce using rule 11 (stat -> BREAK .)
    DO              reduce using rule 11 (stat -> BREAK .)
    WHILE           reduce using rule 11 (stat -> BREAK .)
    REPEAT          reduce using rule 11 (stat -> BREAK .)
    IF              reduce using rule 11 (stat -> BREAK .)
    FOR             reduce using rule 11 (stat -> BREAK .)
    FUNCTION        reduce using rule 11 (stat -> BREAK .)
    LOCAL           reduce using rule 11 (stat -> BREAK .)
    DOUBLECOLON     reduce using rule 11 (stat -> BREAK .)
    RETURN          reduce using rule 11 (stat -> BREAK .)
    IDENTIFIER      reduce using rule 11 (stat -> BREAK .)
    LPAREN          reduce using rule 11 (stat -> BREAK .)
    $end            reduce using rule 11 (stat -> BREAK .)
    END             reduce using rule 11 (stat -> BREAK .)
    UNTIL           reduce using rule 11 (stat -> BREAK .)
    ELSEIF          reduce using rule 11 (stat -> BREAK .)
    ELSE            reduce using rule 11 (stat -> BREAK .)


state 14

    (12) stat -> GOTO . IDENTIFIER

    IDENTIFIER      shift and go to state 30


state 15

    (39) var -> IDENTIFIER .

    ASSIGN          reduce using rule 39 (var -> IDENTIFIER .)
    COMMA           reduce using rule 39 (var -> IDENTIFIER .)
    COLON           reduce using rule 39 (var -> IDENTIFIER .)
    LBRACKET        reduce using rule 39 (var -> IDENTIFIER .)
    DOT             reduce using rule 39 (var -> IDENTIFIER .)
    LPAREN          reduce using rule 39 (var -> IDENTIFIER .)
    STRING          reduce using rule 39 (var -> IDENTIFIER .)
    LBRACE          reduce using rule 39 (var -> IDENTIFIER .)


state 16

    (13) stat -> DO . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 31
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 17

    (14) stat -> WHILE . expression DO block END
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 32
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 18

    (15) stat -> REPEAT . block UNTIL expression
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    UNTIL           reduce using rule 26 (empty -> .)

    block                          shift and go to state 39
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 19

    (16) stat -> IF . expression THEN block elseif_blocks else_block END
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 40
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 20

    (22) stat -> FOR . IDENTIFIER ASSIGN expression COMMA expression DO block END
    (23) stat -> FOR . namelist IN explist DO block END
    (42) namelist -> . IDENTIFIER
    (43) namelist -> . namelist COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 41

    namelist                       shift and go to state 42

state 21

    (24) stat -> FUNCTION . funcname funcbody
    (32) funcname -> . IDENTIFIER funcname_tail method_opt

    IDENTIFIER      shift and go to state 44

    funcname                       shift and go to state 43

state 22

    (25) stat -> LOCAL . FUNCTION IDENTIFIER funcbody

    FUNCTION        shift and go to state 45


state 23

    (31) stat -> DOUBLECOLON . IDENTIFIER DOUBLECOLON

    IDENTIFIER      shift and go to state 46


state 24

    (27) retstat -> RETURN . explist SEMICOLON
    (28) retstat -> RETURN . explist
    (29) retstat -> RETURN . SEMICOLON
    (30) retstat -> RETURN .
    (44) explist -> . expression
    (45) explist -> . explist COMMA expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 48
    $end            reduce using rule 30 (retstat -> RETURN .)
    END             reduce using rule 30 (retstat -> RETURN .)
    UNTIL           reduce using rule 30 (retstat -> RETURN .)
    ELSEIF          reduce using rule 30 (retstat -> RETURN .)
    ELSE            reduce using rule 30 (retstat -> RETURN .)
    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    explist                        shift and go to state 47
    expression                     shift and go to state 49
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 25

    (37) varlist -> var .
    (46) prefixexp -> var .

    ASSIGN          reduce using rule 37 (varlist -> var .)
    COMMA           reduce using rule 37 (varlist -> var .)
    COLON           reduce using rule 46 (prefixexp -> var .)
    LBRACKET        reduce using rule 46 (prefixexp -> var .)
    DOT             reduce using rule 46 (prefixexp -> var .)
    LPAREN          reduce using rule 46 (prefixexp -> var .)
    STRING          reduce using rule 46 (prefixexp -> var .)
    LBRACE          reduce using rule 46 (prefixexp -> var .)


state 26

    (49) functioncall -> prefixexp . args
    (50) functioncall -> prefixexp . COLON IDENTIFIER args
    (40) var -> prefixexp . LBRACKET expression RBRACKET
    (41) var -> prefixexp . DOT IDENTIFIER
    (51) args -> . LPAREN RPAREN
    (52) args -> . LPAREN explist RPAREN
    (53) args -> . STRING
    (54) args -> . tableconstructor
    (62) tableconstructor -> . LBRACE RBRACE
    (63) tableconstructor -> . LBRACE fieldlist RBRACE

    COLON           shift and go to state 51
    LBRACKET        shift and go to state 52
    DOT             shift and go to state 53
    LPAREN          shift and go to state 54
    STRING          shift and go to state 55
    LBRACE          shift and go to state 57

    args                           shift and go to state 50
    tableconstructor               shift and go to state 56

state 27

    (48) prefixexp -> LPAREN . expression RPAREN
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 58
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 28

    (9) stat -> varlist ASSIGN . explist
    (44) explist -> . expression
    (45) explist -> . explist COMMA expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    explist                        shift and go to state 59
    expression                     shift and go to state 49
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 29

    (38) varlist -> varlist COMMA . var
    (39) var -> . IDENTIFIER
    (40) var -> . prefixexp LBRACKET expression RBRACKET
    (41) var -> . prefixexp DOT IDENTIFIER
    (46) prefixexp -> . var
    (47) prefixexp -> . functioncall
    (48) prefixexp -> . LPAREN expression RPAREN
    (49) functioncall -> . prefixexp args
    (50) functioncall -> . prefixexp COLON IDENTIFIER args

    IDENTIFIER      shift and go to state 15
    LPAREN          shift and go to state 27

    var                            shift and go to state 60
    prefixexp                      shift and go to state 61
    functioncall                   shift and go to state 62

state 30

    (12) stat -> GOTO IDENTIFIER .

    SEMICOLON       reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    BREAK           reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    GOTO            reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    DO              reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    WHILE           reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    REPEAT          reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    IF              reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    FOR             reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    FUNCTION        reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    LOCAL           reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    DOUBLECOLON     reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    RETURN          reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    IDENTIFIER      reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    LPAREN          reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    $end            reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    END             reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    UNTIL           reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    ELSEIF          reduce using rule 12 (stat -> GOTO IDENTIFIER .)
    ELSE            reduce using rule 12 (stat -> GOTO IDENTIFIER .)


state 31

    (13) stat -> DO block . END

    END             shift and go to state 63


state 32

    (14) stat -> WHILE expression . DO block END
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    DO              shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 33

    (55) expression -> FUNCTION . funcbody
    (56) funcbody -> . LPAREN RPAREN block END
    (57) funcbody -> . LPAREN parlist RPAREN block END

    LPAREN          shift and go to state 68

    funcbody                       shift and go to state 67

state 34

    (81) expression -> term .
    (78) term -> term . TIMES factor
    (79) term -> term . DIVIDE factor
    (80) term -> term . POWER factor

    DO              reduce using rule 81 (expression -> term .)
    PLUS            reduce using rule 81 (expression -> term .)
    MINUS           reduce using rule 81 (expression -> term .)
    THEN            reduce using rule 81 (expression -> term .)
    SEMICOLON       reduce using rule 81 (expression -> term .)
    COMMA           reduce using rule 81 (expression -> term .)
    $end            reduce using rule 81 (expression -> term .)
    END             reduce using rule 81 (expression -> term .)
    UNTIL           reduce using rule 81 (expression -> term .)
    ELSEIF          reduce using rule 81 (expression -> term .)
    ELSE            reduce using rule 81 (expression -> term .)
    RPAREN          reduce using rule 81 (expression -> term .)
    BREAK           reduce using rule 81 (expression -> term .)
    GOTO            reduce using rule 81 (expression -> term .)
    WHILE           reduce using rule 81 (expression -> term .)
    REPEAT          reduce using rule 81 (expression -> term .)
    IF              reduce using rule 81 (expression -> term .)
    FOR             reduce using rule 81 (expression -> term .)
    FUNCTION        reduce using rule 81 (expression -> term .)
    LOCAL           reduce using rule 81 (expression -> term .)
    DOUBLECOLON     reduce using rule 81 (expression -> term .)
    RETURN          reduce using rule 81 (expression -> term .)
    IDENTIFIER      reduce using rule 81 (expression -> term .)
    LPAREN          reduce using rule 81 (expression -> term .)
    RBRACKET        reduce using rule 81 (expression -> term .)
    RBRACE          reduce using rule 81 (expression -> term .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 35

    (82) term -> factor .

    TIMES           reduce using rule 82 (term -> factor .)
    DIVIDE          reduce using rule 82 (term -> factor .)
    POWER           reduce using rule 82 (term -> factor .)
    DO              reduce using rule 82 (term -> factor .)
    PLUS            reduce using rule 82 (term -> factor .)
    MINUS           reduce using rule 82 (term -> factor .)
    THEN            reduce using rule 82 (term -> factor .)
    SEMICOLON       reduce using rule 82 (term -> factor .)
    COMMA           reduce using rule 82 (term -> factor .)
    $end            reduce using rule 82 (term -> factor .)
    END             reduce using rule 82 (term -> factor .)
    UNTIL           reduce using rule 82 (term -> factor .)
    ELSEIF          reduce using rule 82 (term -> factor .)
    ELSE            reduce using rule 82 (term -> factor .)
    RPAREN          reduce using rule 82 (term -> factor .)
    BREAK           reduce using rule 82 (term -> factor .)
    GOTO            reduce using rule 82 (term -> factor .)
    WHILE           reduce using rule 82 (term -> factor .)
    REPEAT          reduce using rule 82 (term -> factor .)
    IF              reduce using rule 82 (term -> factor .)
    FOR             reduce using rule 82 (term -> factor .)
    FUNCTION        reduce using rule 82 (term -> factor .)
    LOCAL           reduce using rule 82 (term -> factor .)
    DOUBLECOLON     reduce using rule 82 (term -> factor .)
    RETURN          reduce using rule 82 (term -> factor .)
    IDENTIFIER      reduce using rule 82 (term -> factor .)
    LPAREN          reduce using rule 82 (term -> factor .)
    RBRACKET        reduce using rule 82 (term -> factor .)
    RBRACE          reduce using rule 82 (term -> factor .)


state 36

    (83) factor -> INTEGER .

    TIMES           reduce using rule 83 (factor -> INTEGER .)
    DIVIDE          reduce using rule 83 (factor -> INTEGER .)
    POWER           reduce using rule 83 (factor -> INTEGER .)
    DO              reduce using rule 83 (factor -> INTEGER .)
    PLUS            reduce using rule 83 (factor -> INTEGER .)
    MINUS           reduce using rule 83 (factor -> INTEGER .)
    THEN            reduce using rule 83 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 83 (factor -> INTEGER .)
    COMMA           reduce using rule 83 (factor -> INTEGER .)
    $end            reduce using rule 83 (factor -> INTEGER .)
    END             reduce using rule 83 (factor -> INTEGER .)
    UNTIL           reduce using rule 83 (factor -> INTEGER .)
    ELSEIF          reduce using rule 83 (factor -> INTEGER .)
    ELSE            reduce using rule 83 (factor -> INTEGER .)
    RPAREN          reduce using rule 83 (factor -> INTEGER .)
    BREAK           reduce using rule 83 (factor -> INTEGER .)
    GOTO            reduce using rule 83 (factor -> INTEGER .)
    WHILE           reduce using rule 83 (factor -> INTEGER .)
    REPEAT          reduce using rule 83 (factor -> INTEGER .)
    IF              reduce using rule 83 (factor -> INTEGER .)
    FOR             reduce using rule 83 (factor -> INTEGER .)
    FUNCTION        reduce using rule 83 (factor -> INTEGER .)
    LOCAL           reduce using rule 83 (factor -> INTEGER .)
    DOUBLECOLON     reduce using rule 83 (factor -> INTEGER .)
    RETURN          reduce using rule 83 (factor -> INTEGER .)
    IDENTIFIER      reduce using rule 83 (factor -> INTEGER .)
    LPAREN          reduce using rule 83 (factor -> INTEGER .)
    RBRACKET        reduce using rule 83 (factor -> INTEGER .)
    RBRACE          reduce using rule 83 (factor -> INTEGER .)


state 37

    (84) factor -> FLOAT .

    TIMES           reduce using rule 84 (factor -> FLOAT .)
    DIVIDE          reduce using rule 84 (factor -> FLOAT .)
    POWER           reduce using rule 84 (factor -> FLOAT .)
    DO              reduce using rule 84 (factor -> FLOAT .)
    PLUS            reduce using rule 84 (factor -> FLOAT .)
    MINUS           reduce using rule 84 (factor -> FLOAT .)
    THEN            reduce using rule 84 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 84 (factor -> FLOAT .)
    COMMA           reduce using rule 84 (factor -> FLOAT .)
    $end            reduce using rule 84 (factor -> FLOAT .)
    END             reduce using rule 84 (factor -> FLOAT .)
    UNTIL           reduce using rule 84 (factor -> FLOAT .)
    ELSEIF          reduce using rule 84 (factor -> FLOAT .)
    ELSE            reduce using rule 84 (factor -> FLOAT .)
    RPAREN          reduce using rule 84 (factor -> FLOAT .)
    BREAK           reduce using rule 84 (factor -> FLOAT .)
    GOTO            reduce using rule 84 (factor -> FLOAT .)
    WHILE           reduce using rule 84 (factor -> FLOAT .)
    REPEAT          reduce using rule 84 (factor -> FLOAT .)
    IF              reduce using rule 84 (factor -> FLOAT .)
    FOR             reduce using rule 84 (factor -> FLOAT .)
    FUNCTION        reduce using rule 84 (factor -> FLOAT .)
    LOCAL           reduce using rule 84 (factor -> FLOAT .)
    DOUBLECOLON     reduce using rule 84 (factor -> FLOAT .)
    RETURN          reduce using rule 84 (factor -> FLOAT .)
    IDENTIFIER      reduce using rule 84 (factor -> FLOAT .)
    LPAREN          reduce using rule 84 (factor -> FLOAT .)
    RBRACKET        reduce using rule 84 (factor -> FLOAT .)
    RBRACE          reduce using rule 84 (factor -> FLOAT .)


state 38

    (85) factor -> LPAREN . expression RPAREN
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 72
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 39

    (15) stat -> REPEAT block . UNTIL expression

    UNTIL           shift and go to state 73


state 40

    (16) stat -> IF expression . THEN block elseif_blocks else_block END
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            shift and go to state 74
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 41

    (22) stat -> FOR IDENTIFIER . ASSIGN expression COMMA expression DO block END
    (42) namelist -> IDENTIFIER .

    ASSIGN          shift and go to state 75
    IN              reduce using rule 42 (namelist -> IDENTIFIER .)
    COMMA           reduce using rule 42 (namelist -> IDENTIFIER .)


state 42

    (23) stat -> FOR namelist . IN explist DO block END
    (43) namelist -> namelist . COMMA IDENTIFIER

    IN              shift and go to state 76
    COMMA           shift and go to state 77


state 43

    (24) stat -> FUNCTION funcname . funcbody
    (56) funcbody -> . LPAREN RPAREN block END
    (57) funcbody -> . LPAREN parlist RPAREN block END

    LPAREN          shift and go to state 68

    funcbody                       shift and go to state 78

state 44

    (32) funcname -> IDENTIFIER . funcname_tail method_opt
    (33) funcname_tail -> . funcname_tail DOT IDENTIFIER
    (34) funcname_tail -> . empty
    (26) empty -> .

    DOT             reduce using rule 26 (empty -> .)
    COLON           reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)

    funcname_tail                  shift and go to state 79
    empty                          shift and go to state 80

state 45

    (25) stat -> LOCAL FUNCTION . IDENTIFIER funcbody

    IDENTIFIER      shift and go to state 81


state 46

    (31) stat -> DOUBLECOLON IDENTIFIER . DOUBLECOLON

    DOUBLECOLON     shift and go to state 82


state 47

    (27) retstat -> RETURN explist . SEMICOLON
    (28) retstat -> RETURN explist .
    (45) explist -> explist . COMMA expression

    SEMICOLON       shift and go to state 83
    $end            reduce using rule 28 (retstat -> RETURN explist .)
    END             reduce using rule 28 (retstat -> RETURN explist .)
    UNTIL           reduce using rule 28 (retstat -> RETURN explist .)
    ELSEIF          reduce using rule 28 (retstat -> RETURN explist .)
    ELSE            reduce using rule 28 (retstat -> RETURN explist .)
    COMMA           shift and go to state 84


state 48

    (29) retstat -> RETURN SEMICOLON .

    $end            reduce using rule 29 (retstat -> RETURN SEMICOLON .)
    END             reduce using rule 29 (retstat -> RETURN SEMICOLON .)
    UNTIL           reduce using rule 29 (retstat -> RETURN SEMICOLON .)
    ELSEIF          reduce using rule 29 (retstat -> RETURN SEMICOLON .)
    ELSE            reduce using rule 29 (retstat -> RETURN SEMICOLON .)


state 49

    (44) explist -> expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 44 (explist -> expression .)
    COMMA           reduce using rule 44 (explist -> expression .)
    $end            reduce using rule 44 (explist -> expression .)
    END             reduce using rule 44 (explist -> expression .)
    UNTIL           reduce using rule 44 (explist -> expression .)
    ELSEIF          reduce using rule 44 (explist -> expression .)
    ELSE            reduce using rule 44 (explist -> expression .)
    BREAK           reduce using rule 44 (explist -> expression .)
    GOTO            reduce using rule 44 (explist -> expression .)
    DO              reduce using rule 44 (explist -> expression .)
    WHILE           reduce using rule 44 (explist -> expression .)
    REPEAT          reduce using rule 44 (explist -> expression .)
    IF              reduce using rule 44 (explist -> expression .)
    FOR             reduce using rule 44 (explist -> expression .)
    FUNCTION        reduce using rule 44 (explist -> expression .)
    LOCAL           reduce using rule 44 (explist -> expression .)
    DOUBLECOLON     reduce using rule 44 (explist -> expression .)
    RETURN          reduce using rule 44 (explist -> expression .)
    IDENTIFIER      reduce using rule 44 (explist -> expression .)
    LPAREN          reduce using rule 44 (explist -> expression .)
    RPAREN          reduce using rule 44 (explist -> expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 50

    (49) functioncall -> prefixexp args .

    SEMICOLON       reduce using rule 49 (functioncall -> prefixexp args .)
    BREAK           reduce using rule 49 (functioncall -> prefixexp args .)
    GOTO            reduce using rule 49 (functioncall -> prefixexp args .)
    DO              reduce using rule 49 (functioncall -> prefixexp args .)
    WHILE           reduce using rule 49 (functioncall -> prefixexp args .)
    REPEAT          reduce using rule 49 (functioncall -> prefixexp args .)
    IF              reduce using rule 49 (functioncall -> prefixexp args .)
    FOR             reduce using rule 49 (functioncall -> prefixexp args .)
    FUNCTION        reduce using rule 49 (functioncall -> prefixexp args .)
    LOCAL           reduce using rule 49 (functioncall -> prefixexp args .)
    DOUBLECOLON     reduce using rule 49 (functioncall -> prefixexp args .)
    RETURN          reduce using rule 49 (functioncall -> prefixexp args .)
    IDENTIFIER      reduce using rule 49 (functioncall -> prefixexp args .)
    LPAREN          reduce using rule 49 (functioncall -> prefixexp args .)
    $end            reduce using rule 49 (functioncall -> prefixexp args .)
    END             reduce using rule 49 (functioncall -> prefixexp args .)
    UNTIL           reduce using rule 49 (functioncall -> prefixexp args .)
    ELSEIF          reduce using rule 49 (functioncall -> prefixexp args .)
    ELSE            reduce using rule 49 (functioncall -> prefixexp args .)
    COLON           reduce using rule 49 (functioncall -> prefixexp args .)
    LBRACKET        reduce using rule 49 (functioncall -> prefixexp args .)
    DOT             reduce using rule 49 (functioncall -> prefixexp args .)
    STRING          reduce using rule 49 (functioncall -> prefixexp args .)
    LBRACE          reduce using rule 49 (functioncall -> prefixexp args .)


state 51

    (50) functioncall -> prefixexp COLON . IDENTIFIER args

    IDENTIFIER      shift and go to state 85


state 52

    (40) var -> prefixexp LBRACKET . expression RBRACKET
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 86
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 53

    (41) var -> prefixexp DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 87


state 54

    (51) args -> LPAREN . RPAREN
    (52) args -> LPAREN . explist RPAREN
    (44) explist -> . expression
    (45) explist -> . explist COMMA expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    RPAREN          shift and go to state 88
    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    explist                        shift and go to state 89
    expression                     shift and go to state 49
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 55

    (53) args -> STRING .

    SEMICOLON       reduce using rule 53 (args -> STRING .)
    BREAK           reduce using rule 53 (args -> STRING .)
    GOTO            reduce using rule 53 (args -> STRING .)
    DO              reduce using rule 53 (args -> STRING .)
    WHILE           reduce using rule 53 (args -> STRING .)
    REPEAT          reduce using rule 53 (args -> STRING .)
    IF              reduce using rule 53 (args -> STRING .)
    FOR             reduce using rule 53 (args -> STRING .)
    FUNCTION        reduce using rule 53 (args -> STRING .)
    LOCAL           reduce using rule 53 (args -> STRING .)
    DOUBLECOLON     reduce using rule 53 (args -> STRING .)
    RETURN          reduce using rule 53 (args -> STRING .)
    IDENTIFIER      reduce using rule 53 (args -> STRING .)
    LPAREN          reduce using rule 53 (args -> STRING .)
    $end            reduce using rule 53 (args -> STRING .)
    END             reduce using rule 53 (args -> STRING .)
    UNTIL           reduce using rule 53 (args -> STRING .)
    ELSEIF          reduce using rule 53 (args -> STRING .)
    ELSE            reduce using rule 53 (args -> STRING .)
    COLON           reduce using rule 53 (args -> STRING .)
    LBRACKET        reduce using rule 53 (args -> STRING .)
    DOT             reduce using rule 53 (args -> STRING .)
    STRING          reduce using rule 53 (args -> STRING .)
    LBRACE          reduce using rule 53 (args -> STRING .)


state 56

    (54) args -> tableconstructor .

    SEMICOLON       reduce using rule 54 (args -> tableconstructor .)
    BREAK           reduce using rule 54 (args -> tableconstructor .)
    GOTO            reduce using rule 54 (args -> tableconstructor .)
    DO              reduce using rule 54 (args -> tableconstructor .)
    WHILE           reduce using rule 54 (args -> tableconstructor .)
    REPEAT          reduce using rule 54 (args -> tableconstructor .)
    IF              reduce using rule 54 (args -> tableconstructor .)
    FOR             reduce using rule 54 (args -> tableconstructor .)
    FUNCTION        reduce using rule 54 (args -> tableconstructor .)
    LOCAL           reduce using rule 54 (args -> tableconstructor .)
    DOUBLECOLON     reduce using rule 54 (args -> tableconstructor .)
    RETURN          reduce using rule 54 (args -> tableconstructor .)
    IDENTIFIER      reduce using rule 54 (args -> tableconstructor .)
    LPAREN          reduce using rule 54 (args -> tableconstructor .)
    $end            reduce using rule 54 (args -> tableconstructor .)
    END             reduce using rule 54 (args -> tableconstructor .)
    UNTIL           reduce using rule 54 (args -> tableconstructor .)
    ELSEIF          reduce using rule 54 (args -> tableconstructor .)
    ELSE            reduce using rule 54 (args -> tableconstructor .)
    COLON           reduce using rule 54 (args -> tableconstructor .)
    LBRACKET        reduce using rule 54 (args -> tableconstructor .)
    DOT             reduce using rule 54 (args -> tableconstructor .)
    STRING          reduce using rule 54 (args -> tableconstructor .)
    LBRACE          reduce using rule 54 (args -> tableconstructor .)


state 57

    (62) tableconstructor -> LBRACE . RBRACE
    (63) tableconstructor -> LBRACE . fieldlist RBRACE
    (64) fieldlist -> . field fieldsep_tail
    (69) field -> . LBRACKET expression RBRACKET ASSIGN expression
    (70) field -> . IDENTIFIER ASSIGN expression
    (71) field -> . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    RBRACE          shift and go to state 90
    LBRACKET        shift and go to state 93
    IDENTIFIER      shift and go to state 95
    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    fieldlist                      shift and go to state 91
    field                          shift and go to state 92
    expression                     shift and go to state 94
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 58

    (48) prefixexp -> LPAREN expression . RPAREN
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          shift and go to state 96
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 59

    (9) stat -> varlist ASSIGN explist .
    (45) explist -> explist . COMMA expression

    SEMICOLON       reduce using rule 9 (stat -> varlist ASSIGN explist .)
    BREAK           reduce using rule 9 (stat -> varlist ASSIGN explist .)
    GOTO            reduce using rule 9 (stat -> varlist ASSIGN explist .)
    DO              reduce using rule 9 (stat -> varlist ASSIGN explist .)
    WHILE           reduce using rule 9 (stat -> varlist ASSIGN explist .)
    REPEAT          reduce using rule 9 (stat -> varlist ASSIGN explist .)
    IF              reduce using rule 9 (stat -> varlist ASSIGN explist .)
    FOR             reduce using rule 9 (stat -> varlist ASSIGN explist .)
    FUNCTION        reduce using rule 9 (stat -> varlist ASSIGN explist .)
    LOCAL           reduce using rule 9 (stat -> varlist ASSIGN explist .)
    DOUBLECOLON     reduce using rule 9 (stat -> varlist ASSIGN explist .)
    RETURN          reduce using rule 9 (stat -> varlist ASSIGN explist .)
    IDENTIFIER      reduce using rule 9 (stat -> varlist ASSIGN explist .)
    LPAREN          reduce using rule 9 (stat -> varlist ASSIGN explist .)
    $end            reduce using rule 9 (stat -> varlist ASSIGN explist .)
    END             reduce using rule 9 (stat -> varlist ASSIGN explist .)
    UNTIL           reduce using rule 9 (stat -> varlist ASSIGN explist .)
    ELSEIF          reduce using rule 9 (stat -> varlist ASSIGN explist .)
    ELSE            reduce using rule 9 (stat -> varlist ASSIGN explist .)
    COMMA           shift and go to state 84


state 60

    (38) varlist -> varlist COMMA var .
    (46) prefixexp -> var .

    ASSIGN          reduce using rule 38 (varlist -> varlist COMMA var .)
    COMMA           reduce using rule 38 (varlist -> varlist COMMA var .)
    LBRACKET        reduce using rule 46 (prefixexp -> var .)
    DOT             reduce using rule 46 (prefixexp -> var .)
    COLON           reduce using rule 46 (prefixexp -> var .)
    LPAREN          reduce using rule 46 (prefixexp -> var .)
    STRING          reduce using rule 46 (prefixexp -> var .)
    LBRACE          reduce using rule 46 (prefixexp -> var .)


state 61

    (40) var -> prefixexp . LBRACKET expression RBRACKET
    (41) var -> prefixexp . DOT IDENTIFIER
    (49) functioncall -> prefixexp . args
    (50) functioncall -> prefixexp . COLON IDENTIFIER args
    (51) args -> . LPAREN RPAREN
    (52) args -> . LPAREN explist RPAREN
    (53) args -> . STRING
    (54) args -> . tableconstructor
    (62) tableconstructor -> . LBRACE RBRACE
    (63) tableconstructor -> . LBRACE fieldlist RBRACE

    LBRACKET        shift and go to state 52
    DOT             shift and go to state 53
    COLON           shift and go to state 51
    LPAREN          shift and go to state 54
    STRING          shift and go to state 55
    LBRACE          shift and go to state 57

    args                           shift and go to state 50
    tableconstructor               shift and go to state 56

state 62

    (47) prefixexp -> functioncall .

    LBRACKET        reduce using rule 47 (prefixexp -> functioncall .)
    DOT             reduce using rule 47 (prefixexp -> functioncall .)
    COLON           reduce using rule 47 (prefixexp -> functioncall .)
    LPAREN          reduce using rule 47 (prefixexp -> functioncall .)
    STRING          reduce using rule 47 (prefixexp -> functioncall .)
    LBRACE          reduce using rule 47 (prefixexp -> functioncall .)


state 63

    (13) stat -> DO block END .

    SEMICOLON       reduce using rule 13 (stat -> DO block END .)
    BREAK           reduce using rule 13 (stat -> DO block END .)
    GOTO            reduce using rule 13 (stat -> DO block END .)
    DO              reduce using rule 13 (stat -> DO block END .)
    WHILE           reduce using rule 13 (stat -> DO block END .)
    REPEAT          reduce using rule 13 (stat -> DO block END .)
    IF              reduce using rule 13 (stat -> DO block END .)
    FOR             reduce using rule 13 (stat -> DO block END .)
    FUNCTION        reduce using rule 13 (stat -> DO block END .)
    LOCAL           reduce using rule 13 (stat -> DO block END .)
    DOUBLECOLON     reduce using rule 13 (stat -> DO block END .)
    RETURN          reduce using rule 13 (stat -> DO block END .)
    IDENTIFIER      reduce using rule 13 (stat -> DO block END .)
    LPAREN          reduce using rule 13 (stat -> DO block END .)
    $end            reduce using rule 13 (stat -> DO block END .)
    END             reduce using rule 13 (stat -> DO block END .)
    UNTIL           reduce using rule 13 (stat -> DO block END .)
    ELSEIF          reduce using rule 13 (stat -> DO block END .)
    ELSE            reduce using rule 13 (stat -> DO block END .)


state 64

    (14) stat -> WHILE expression DO . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 97
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 65

    (76) expression -> expression PLUS . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    term                           shift and go to state 98
    factor                         shift and go to state 35

state 66

    (77) expression -> expression MINUS . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    term                           shift and go to state 99
    factor                         shift and go to state 35

state 67

    (55) expression -> FUNCTION funcbody .

    DO              reduce using rule 55 (expression -> FUNCTION funcbody .)
    PLUS            reduce using rule 55 (expression -> FUNCTION funcbody .)
    MINUS           reduce using rule 55 (expression -> FUNCTION funcbody .)
    THEN            reduce using rule 55 (expression -> FUNCTION funcbody .)
    SEMICOLON       reduce using rule 55 (expression -> FUNCTION funcbody .)
    COMMA           reduce using rule 55 (expression -> FUNCTION funcbody .)
    $end            reduce using rule 55 (expression -> FUNCTION funcbody .)
    END             reduce using rule 55 (expression -> FUNCTION funcbody .)
    UNTIL           reduce using rule 55 (expression -> FUNCTION funcbody .)
    ELSEIF          reduce using rule 55 (expression -> FUNCTION funcbody .)
    ELSE            reduce using rule 55 (expression -> FUNCTION funcbody .)
    RPAREN          reduce using rule 55 (expression -> FUNCTION funcbody .)
    BREAK           reduce using rule 55 (expression -> FUNCTION funcbody .)
    GOTO            reduce using rule 55 (expression -> FUNCTION funcbody .)
    WHILE           reduce using rule 55 (expression -> FUNCTION funcbody .)
    REPEAT          reduce using rule 55 (expression -> FUNCTION funcbody .)
    IF              reduce using rule 55 (expression -> FUNCTION funcbody .)
    FOR             reduce using rule 55 (expression -> FUNCTION funcbody .)
    FUNCTION        reduce using rule 55 (expression -> FUNCTION funcbody .)
    LOCAL           reduce using rule 55 (expression -> FUNCTION funcbody .)
    DOUBLECOLON     reduce using rule 55 (expression -> FUNCTION funcbody .)
    RETURN          reduce using rule 55 (expression -> FUNCTION funcbody .)
    IDENTIFIER      reduce using rule 55 (expression -> FUNCTION funcbody .)
    LPAREN          reduce using rule 55 (expression -> FUNCTION funcbody .)
    RBRACKET        reduce using rule 55 (expression -> FUNCTION funcbody .)
    RBRACE          reduce using rule 55 (expression -> FUNCTION funcbody .)


state 68

    (56) funcbody -> LPAREN . RPAREN block END
    (57) funcbody -> LPAREN . parlist RPAREN block END
    (58) parlist -> . namelist vararg_tail
    (59) parlist -> . VARARG
    (42) namelist -> . IDENTIFIER
    (43) namelist -> . namelist COMMA IDENTIFIER

    RPAREN          shift and go to state 100
    VARARG          shift and go to state 103
    IDENTIFIER      shift and go to state 104

    parlist                        shift and go to state 101
    namelist                       shift and go to state 102

state 69

    (78) term -> term TIMES . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    factor                         shift and go to state 105

state 70

    (79) term -> term DIVIDE . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    factor                         shift and go to state 106

state 71

    (80) term -> term POWER . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    factor                         shift and go to state 107

state 72

    (85) factor -> LPAREN expression . RPAREN
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RPAREN          shift and go to state 108
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 73

    (15) stat -> REPEAT block UNTIL . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 109
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 74

    (16) stat -> IF expression THEN . block elseif_blocks else_block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    ELSEIF          reduce using rule 26 (empty -> .)
    ELSE            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 110
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 75

    (22) stat -> FOR IDENTIFIER ASSIGN . expression COMMA expression DO block END
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 111
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 76

    (23) stat -> FOR namelist IN . explist DO block END
    (44) explist -> . expression
    (45) explist -> . explist COMMA expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    explist                        shift and go to state 112
    expression                     shift and go to state 49
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 77

    (43) namelist -> namelist COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 113


state 78

    (24) stat -> FUNCTION funcname funcbody .

    SEMICOLON       reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    BREAK           reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    GOTO            reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    DO              reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    WHILE           reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    REPEAT          reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    IF              reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    FOR             reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    FUNCTION        reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    LOCAL           reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    DOUBLECOLON     reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    RETURN          reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    IDENTIFIER      reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    LPAREN          reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    $end            reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    END             reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    UNTIL           reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    ELSEIF          reduce using rule 24 (stat -> FUNCTION funcname funcbody .)
    ELSE            reduce using rule 24 (stat -> FUNCTION funcname funcbody .)


state 79

    (32) funcname -> IDENTIFIER funcname_tail . method_opt
    (33) funcname_tail -> funcname_tail . DOT IDENTIFIER
    (35) method_opt -> . COLON IDENTIFIER
    (36) method_opt -> . empty
    (26) empty -> .

    DOT             shift and go to state 115
    COLON           shift and go to state 116
    LPAREN          reduce using rule 26 (empty -> .)

    method_opt                     shift and go to state 114
    empty                          shift and go to state 117

state 80

    (34) funcname_tail -> empty .

    DOT             reduce using rule 34 (funcname_tail -> empty .)
    COLON           reduce using rule 34 (funcname_tail -> empty .)
    LPAREN          reduce using rule 34 (funcname_tail -> empty .)


state 81

    (25) stat -> LOCAL FUNCTION IDENTIFIER . funcbody
    (56) funcbody -> . LPAREN RPAREN block END
    (57) funcbody -> . LPAREN parlist RPAREN block END

    LPAREN          shift and go to state 68

    funcbody                       shift and go to state 118

state 82

    (31) stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .

    SEMICOLON       reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    BREAK           reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    GOTO            reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    DO              reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    WHILE           reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    REPEAT          reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    IF              reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    FOR             reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    FUNCTION        reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    LOCAL           reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    DOUBLECOLON     reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    RETURN          reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    IDENTIFIER      reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    LPAREN          reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    $end            reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    END             reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    UNTIL           reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    ELSEIF          reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)
    ELSE            reduce using rule 31 (stat -> DOUBLECOLON IDENTIFIER DOUBLECOLON .)


state 83

    (27) retstat -> RETURN explist SEMICOLON .

    $end            reduce using rule 27 (retstat -> RETURN explist SEMICOLON .)
    END             reduce using rule 27 (retstat -> RETURN explist SEMICOLON .)
    UNTIL           reduce using rule 27 (retstat -> RETURN explist SEMICOLON .)
    ELSEIF          reduce using rule 27 (retstat -> RETURN explist SEMICOLON .)
    ELSE            reduce using rule 27 (retstat -> RETURN explist SEMICOLON .)


state 84

    (45) explist -> explist COMMA . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 119
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 85

    (50) functioncall -> prefixexp COLON IDENTIFIER . args
    (51) args -> . LPAREN RPAREN
    (52) args -> . LPAREN explist RPAREN
    (53) args -> . STRING
    (54) args -> . tableconstructor
    (62) tableconstructor -> . LBRACE RBRACE
    (63) tableconstructor -> . LBRACE fieldlist RBRACE

    LPAREN          shift and go to state 54
    STRING          shift and go to state 55
    LBRACE          shift and go to state 57

    args                           shift and go to state 120
    tableconstructor               shift and go to state 56

state 86

    (40) var -> prefixexp LBRACKET expression . RBRACKET
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RBRACKET        shift and go to state 121
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 87

    (41) var -> prefixexp DOT IDENTIFIER .

    ASSIGN          reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    COMMA           reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    COLON           reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    LBRACKET        reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    DOT             reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    LPAREN          reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    STRING          reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)
    LBRACE          reduce using rule 41 (var -> prefixexp DOT IDENTIFIER .)


state 88

    (51) args -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 51 (args -> LPAREN RPAREN .)
    BREAK           reduce using rule 51 (args -> LPAREN RPAREN .)
    GOTO            reduce using rule 51 (args -> LPAREN RPAREN .)
    DO              reduce using rule 51 (args -> LPAREN RPAREN .)
    WHILE           reduce using rule 51 (args -> LPAREN RPAREN .)
    REPEAT          reduce using rule 51 (args -> LPAREN RPAREN .)
    IF              reduce using rule 51 (args -> LPAREN RPAREN .)
    FOR             reduce using rule 51 (args -> LPAREN RPAREN .)
    FUNCTION        reduce using rule 51 (args -> LPAREN RPAREN .)
    LOCAL           reduce using rule 51 (args -> LPAREN RPAREN .)
    DOUBLECOLON     reduce using rule 51 (args -> LPAREN RPAREN .)
    RETURN          reduce using rule 51 (args -> LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 51 (args -> LPAREN RPAREN .)
    LPAREN          reduce using rule 51 (args -> LPAREN RPAREN .)
    $end            reduce using rule 51 (args -> LPAREN RPAREN .)
    END             reduce using rule 51 (args -> LPAREN RPAREN .)
    UNTIL           reduce using rule 51 (args -> LPAREN RPAREN .)
    ELSEIF          reduce using rule 51 (args -> LPAREN RPAREN .)
    ELSE            reduce using rule 51 (args -> LPAREN RPAREN .)
    COLON           reduce using rule 51 (args -> LPAREN RPAREN .)
    LBRACKET        reduce using rule 51 (args -> LPAREN RPAREN .)
    DOT             reduce using rule 51 (args -> LPAREN RPAREN .)
    STRING          reduce using rule 51 (args -> LPAREN RPAREN .)
    LBRACE          reduce using rule 51 (args -> LPAREN RPAREN .)


state 89

    (52) args -> LPAREN explist . RPAREN
    (45) explist -> explist . COMMA expression

    RPAREN          shift and go to state 122
    COMMA           shift and go to state 84


state 90

    (62) tableconstructor -> LBRACE RBRACE .

    SEMICOLON       reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    BREAK           reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    GOTO            reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    DO              reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    WHILE           reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    REPEAT          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    IF              reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    FOR             reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    LOCAL           reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    DOUBLECOLON     reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    RETURN          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    LPAREN          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    $end            reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    END             reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    UNTIL           reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    ELSEIF          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    ELSE            reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    COLON           reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    DOT             reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    STRING          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)
    LBRACE          reduce using rule 62 (tableconstructor -> LBRACE RBRACE .)


state 91

    (63) tableconstructor -> LBRACE fieldlist . RBRACE

    RBRACE          shift and go to state 123


state 92

    (64) fieldlist -> field . fieldsep_tail
    (65) fieldsep_tail -> . fieldsep fieldfield_tail_opt
    (66) fieldsep_tail -> . empty
    (72) fieldsep -> . COMMA
    (73) fieldsep -> . SEMICOLON
    (26) empty -> .

    COMMA           shift and go to state 127
    SEMICOLON       shift and go to state 128
    RBRACE          reduce using rule 26 (empty -> .)

    fieldsep_tail                  shift and go to state 124
    fieldsep                       shift and go to state 125
    empty                          shift and go to state 126

state 93

    (69) field -> LBRACKET . expression RBRACKET ASSIGN expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 129
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 94

    (71) field -> expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    COMMA           reduce using rule 71 (field -> expression .)
    SEMICOLON       reduce using rule 71 (field -> expression .)
    RBRACE          reduce using rule 71 (field -> expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 95

    (70) field -> IDENTIFIER . ASSIGN expression

    ASSIGN          shift and go to state 130


state 96

    (48) prefixexp -> LPAREN expression RPAREN .

    COLON           reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)
    DOT             reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)
    STRING          reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 48 (prefixexp -> LPAREN expression RPAREN .)


state 97

    (14) stat -> WHILE expression DO block . END

    END             shift and go to state 131


state 98

    (76) expression -> expression PLUS term .
    (78) term -> term . TIMES factor
    (79) term -> term . DIVIDE factor
    (80) term -> term . POWER factor

    DO              reduce using rule 76 (expression -> expression PLUS term .)
    PLUS            reduce using rule 76 (expression -> expression PLUS term .)
    MINUS           reduce using rule 76 (expression -> expression PLUS term .)
    THEN            reduce using rule 76 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 76 (expression -> expression PLUS term .)
    COMMA           reduce using rule 76 (expression -> expression PLUS term .)
    $end            reduce using rule 76 (expression -> expression PLUS term .)
    END             reduce using rule 76 (expression -> expression PLUS term .)
    UNTIL           reduce using rule 76 (expression -> expression PLUS term .)
    ELSEIF          reduce using rule 76 (expression -> expression PLUS term .)
    ELSE            reduce using rule 76 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 76 (expression -> expression PLUS term .)
    BREAK           reduce using rule 76 (expression -> expression PLUS term .)
    GOTO            reduce using rule 76 (expression -> expression PLUS term .)
    WHILE           reduce using rule 76 (expression -> expression PLUS term .)
    REPEAT          reduce using rule 76 (expression -> expression PLUS term .)
    IF              reduce using rule 76 (expression -> expression PLUS term .)
    FOR             reduce using rule 76 (expression -> expression PLUS term .)
    FUNCTION        reduce using rule 76 (expression -> expression PLUS term .)
    LOCAL           reduce using rule 76 (expression -> expression PLUS term .)
    DOUBLECOLON     reduce using rule 76 (expression -> expression PLUS term .)
    RETURN          reduce using rule 76 (expression -> expression PLUS term .)
    IDENTIFIER      reduce using rule 76 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 76 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 76 (expression -> expression PLUS term .)
    RBRACE          reduce using rule 76 (expression -> expression PLUS term .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 99

    (77) expression -> expression MINUS term .
    (78) term -> term . TIMES factor
    (79) term -> term . DIVIDE factor
    (80) term -> term . POWER factor

    DO              reduce using rule 77 (expression -> expression MINUS term .)
    PLUS            reduce using rule 77 (expression -> expression MINUS term .)
    MINUS           reduce using rule 77 (expression -> expression MINUS term .)
    THEN            reduce using rule 77 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 77 (expression -> expression MINUS term .)
    COMMA           reduce using rule 77 (expression -> expression MINUS term .)
    $end            reduce using rule 77 (expression -> expression MINUS term .)
    END             reduce using rule 77 (expression -> expression MINUS term .)
    UNTIL           reduce using rule 77 (expression -> expression MINUS term .)
    ELSEIF          reduce using rule 77 (expression -> expression MINUS term .)
    ELSE            reduce using rule 77 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 77 (expression -> expression MINUS term .)
    BREAK           reduce using rule 77 (expression -> expression MINUS term .)
    GOTO            reduce using rule 77 (expression -> expression MINUS term .)
    WHILE           reduce using rule 77 (expression -> expression MINUS term .)
    REPEAT          reduce using rule 77 (expression -> expression MINUS term .)
    IF              reduce using rule 77 (expression -> expression MINUS term .)
    FOR             reduce using rule 77 (expression -> expression MINUS term .)
    FUNCTION        reduce using rule 77 (expression -> expression MINUS term .)
    LOCAL           reduce using rule 77 (expression -> expression MINUS term .)
    DOUBLECOLON     reduce using rule 77 (expression -> expression MINUS term .)
    RETURN          reduce using rule 77 (expression -> expression MINUS term .)
    IDENTIFIER      reduce using rule 77 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 77 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 77 (expression -> expression MINUS term .)
    RBRACE          reduce using rule 77 (expression -> expression MINUS term .)
    TIMES           shift and go to state 69
    DIVIDE          shift and go to state 70
    POWER           shift and go to state 71


state 100

    (56) funcbody -> LPAREN RPAREN . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 132
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 101

    (57) funcbody -> LPAREN parlist . RPAREN block END

    RPAREN          shift and go to state 133


state 102

    (58) parlist -> namelist . vararg_tail
    (43) namelist -> namelist . COMMA IDENTIFIER
    (60) vararg_tail -> . COMMA VARARG
    (61) vararg_tail -> . empty
    (26) empty -> .

    COMMA           shift and go to state 135
    RPAREN          reduce using rule 26 (empty -> .)

    vararg_tail                    shift and go to state 134
    empty                          shift and go to state 136

state 103

    (59) parlist -> VARARG .

    RPAREN          reduce using rule 59 (parlist -> VARARG .)


state 104

    (42) namelist -> IDENTIFIER .

    COMMA           reduce using rule 42 (namelist -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (namelist -> IDENTIFIER .)


state 105

    (78) term -> term TIMES factor .

    TIMES           reduce using rule 78 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 78 (term -> term TIMES factor .)
    POWER           reduce using rule 78 (term -> term TIMES factor .)
    DO              reduce using rule 78 (term -> term TIMES factor .)
    PLUS            reduce using rule 78 (term -> term TIMES factor .)
    MINUS           reduce using rule 78 (term -> term TIMES factor .)
    THEN            reduce using rule 78 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 78 (term -> term TIMES factor .)
    COMMA           reduce using rule 78 (term -> term TIMES factor .)
    $end            reduce using rule 78 (term -> term TIMES factor .)
    END             reduce using rule 78 (term -> term TIMES factor .)
    UNTIL           reduce using rule 78 (term -> term TIMES factor .)
    ELSEIF          reduce using rule 78 (term -> term TIMES factor .)
    ELSE            reduce using rule 78 (term -> term TIMES factor .)
    RPAREN          reduce using rule 78 (term -> term TIMES factor .)
    BREAK           reduce using rule 78 (term -> term TIMES factor .)
    GOTO            reduce using rule 78 (term -> term TIMES factor .)
    WHILE           reduce using rule 78 (term -> term TIMES factor .)
    REPEAT          reduce using rule 78 (term -> term TIMES factor .)
    IF              reduce using rule 78 (term -> term TIMES factor .)
    FOR             reduce using rule 78 (term -> term TIMES factor .)
    FUNCTION        reduce using rule 78 (term -> term TIMES factor .)
    LOCAL           reduce using rule 78 (term -> term TIMES factor .)
    DOUBLECOLON     reduce using rule 78 (term -> term TIMES factor .)
    RETURN          reduce using rule 78 (term -> term TIMES factor .)
    IDENTIFIER      reduce using rule 78 (term -> term TIMES factor .)
    LPAREN          reduce using rule 78 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 78 (term -> term TIMES factor .)
    RBRACE          reduce using rule 78 (term -> term TIMES factor .)


state 106

    (79) term -> term DIVIDE factor .

    TIMES           reduce using rule 79 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 79 (term -> term DIVIDE factor .)
    POWER           reduce using rule 79 (term -> term DIVIDE factor .)
    DO              reduce using rule 79 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 79 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 79 (term -> term DIVIDE factor .)
    THEN            reduce using rule 79 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 79 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 79 (term -> term DIVIDE factor .)
    $end            reduce using rule 79 (term -> term DIVIDE factor .)
    END             reduce using rule 79 (term -> term DIVIDE factor .)
    UNTIL           reduce using rule 79 (term -> term DIVIDE factor .)
    ELSEIF          reduce using rule 79 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 79 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 79 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 79 (term -> term DIVIDE factor .)
    GOTO            reduce using rule 79 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 79 (term -> term DIVIDE factor .)
    REPEAT          reduce using rule 79 (term -> term DIVIDE factor .)
    IF              reduce using rule 79 (term -> term DIVIDE factor .)
    FOR             reduce using rule 79 (term -> term DIVIDE factor .)
    FUNCTION        reduce using rule 79 (term -> term DIVIDE factor .)
    LOCAL           reduce using rule 79 (term -> term DIVIDE factor .)
    DOUBLECOLON     reduce using rule 79 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 79 (term -> term DIVIDE factor .)
    IDENTIFIER      reduce using rule 79 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 79 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 79 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 79 (term -> term DIVIDE factor .)


state 107

    (80) term -> term POWER factor .

    TIMES           reduce using rule 80 (term -> term POWER factor .)
    DIVIDE          reduce using rule 80 (term -> term POWER factor .)
    POWER           reduce using rule 80 (term -> term POWER factor .)
    DO              reduce using rule 80 (term -> term POWER factor .)
    PLUS            reduce using rule 80 (term -> term POWER factor .)
    MINUS           reduce using rule 80 (term -> term POWER factor .)
    THEN            reduce using rule 80 (term -> term POWER factor .)
    SEMICOLON       reduce using rule 80 (term -> term POWER factor .)
    COMMA           reduce using rule 80 (term -> term POWER factor .)
    $end            reduce using rule 80 (term -> term POWER factor .)
    END             reduce using rule 80 (term -> term POWER factor .)
    UNTIL           reduce using rule 80 (term -> term POWER factor .)
    ELSEIF          reduce using rule 80 (term -> term POWER factor .)
    ELSE            reduce using rule 80 (term -> term POWER factor .)
    RPAREN          reduce using rule 80 (term -> term POWER factor .)
    BREAK           reduce using rule 80 (term -> term POWER factor .)
    GOTO            reduce using rule 80 (term -> term POWER factor .)
    WHILE           reduce using rule 80 (term -> term POWER factor .)
    REPEAT          reduce using rule 80 (term -> term POWER factor .)
    IF              reduce using rule 80 (term -> term POWER factor .)
    FOR             reduce using rule 80 (term -> term POWER factor .)
    FUNCTION        reduce using rule 80 (term -> term POWER factor .)
    LOCAL           reduce using rule 80 (term -> term POWER factor .)
    DOUBLECOLON     reduce using rule 80 (term -> term POWER factor .)
    RETURN          reduce using rule 80 (term -> term POWER factor .)
    IDENTIFIER      reduce using rule 80 (term -> term POWER factor .)
    LPAREN          reduce using rule 80 (term -> term POWER factor .)
    RBRACKET        reduce using rule 80 (term -> term POWER factor .)
    RBRACE          reduce using rule 80 (term -> term POWER factor .)


state 108

    (85) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    POWER           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    ELSEIF          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    GOTO            reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    FUNCTION        reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    LOCAL           reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    DOUBLECOLON     reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 85 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 85 (factor -> LPAREN expression RPAREN .)


state 109

    (15) stat -> REPEAT block UNTIL expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    BREAK           reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    GOTO            reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    DO              reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    WHILE           reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    REPEAT          reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    IF              reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    FOR             reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    FUNCTION        reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    LOCAL           reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    DOUBLECOLON     reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    RETURN          reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    IDENTIFIER      reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    LPAREN          reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    $end            reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    END             reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    UNTIL           reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    ELSEIF          reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    ELSE            reduce using rule 15 (stat -> REPEAT block UNTIL expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 110

    (16) stat -> IF expression THEN block . elseif_blocks else_block END
    (17) elseif_blocks -> . ELSEIF expression THEN block
    (18) elseif_blocks -> . elseif_blocks ELSEIF expression THEN block
    (19) elseif_blocks -> . empty
    (26) empty -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 138
    ELSE            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

  ! ELSEIF          [ reduce using rule 26 (empty -> .) ]

    elseif_blocks                  shift and go to state 137
    empty                          shift and go to state 139

state 111

    (22) stat -> FOR IDENTIFIER ASSIGN expression . COMMA expression DO block END
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    COMMA           shift and go to state 140
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 112

    (23) stat -> FOR namelist IN explist . DO block END
    (45) explist -> explist . COMMA expression

    DO              shift and go to state 141
    COMMA           shift and go to state 84


state 113

    (43) namelist -> namelist COMMA IDENTIFIER .

    IN              reduce using rule 43 (namelist -> namelist COMMA IDENTIFIER .)
    COMMA           reduce using rule 43 (namelist -> namelist COMMA IDENTIFIER .)
    RPAREN          reduce using rule 43 (namelist -> namelist COMMA IDENTIFIER .)


state 114

    (32) funcname -> IDENTIFIER funcname_tail method_opt .

    LPAREN          reduce using rule 32 (funcname -> IDENTIFIER funcname_tail method_opt .)


state 115

    (33) funcname_tail -> funcname_tail DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 142


state 116

    (35) method_opt -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 143


state 117

    (36) method_opt -> empty .

    LPAREN          reduce using rule 36 (method_opt -> empty .)


state 118

    (25) stat -> LOCAL FUNCTION IDENTIFIER funcbody .

    SEMICOLON       reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    BREAK           reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    GOTO            reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    DO              reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    WHILE           reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    REPEAT          reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    IF              reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    FOR             reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    FUNCTION        reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    LOCAL           reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    DOUBLECOLON     reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    RETURN          reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    IDENTIFIER      reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    LPAREN          reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    $end            reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    END             reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    UNTIL           reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    ELSEIF          reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)
    ELSE            reduce using rule 25 (stat -> LOCAL FUNCTION IDENTIFIER funcbody .)


state 119

    (45) explist -> explist COMMA expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 45 (explist -> explist COMMA expression .)
    COMMA           reduce using rule 45 (explist -> explist COMMA expression .)
    $end            reduce using rule 45 (explist -> explist COMMA expression .)
    END             reduce using rule 45 (explist -> explist COMMA expression .)
    UNTIL           reduce using rule 45 (explist -> explist COMMA expression .)
    ELSEIF          reduce using rule 45 (explist -> explist COMMA expression .)
    ELSE            reduce using rule 45 (explist -> explist COMMA expression .)
    BREAK           reduce using rule 45 (explist -> explist COMMA expression .)
    GOTO            reduce using rule 45 (explist -> explist COMMA expression .)
    DO              reduce using rule 45 (explist -> explist COMMA expression .)
    WHILE           reduce using rule 45 (explist -> explist COMMA expression .)
    REPEAT          reduce using rule 45 (explist -> explist COMMA expression .)
    IF              reduce using rule 45 (explist -> explist COMMA expression .)
    FOR             reduce using rule 45 (explist -> explist COMMA expression .)
    FUNCTION        reduce using rule 45 (explist -> explist COMMA expression .)
    LOCAL           reduce using rule 45 (explist -> explist COMMA expression .)
    DOUBLECOLON     reduce using rule 45 (explist -> explist COMMA expression .)
    RETURN          reduce using rule 45 (explist -> explist COMMA expression .)
    IDENTIFIER      reduce using rule 45 (explist -> explist COMMA expression .)
    LPAREN          reduce using rule 45 (explist -> explist COMMA expression .)
    RPAREN          reduce using rule 45 (explist -> explist COMMA expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 120

    (50) functioncall -> prefixexp COLON IDENTIFIER args .

    SEMICOLON       reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    BREAK           reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    GOTO            reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    DO              reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    WHILE           reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    REPEAT          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    IF              reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    FOR             reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    FUNCTION        reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LOCAL           reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    DOUBLECOLON     reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    RETURN          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    IDENTIFIER      reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LPAREN          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    $end            reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    END             reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    UNTIL           reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    ELSEIF          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    ELSE            reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    COLON           reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LBRACKET        reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    DOT             reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    STRING          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LBRACE          reduce using rule 50 (functioncall -> prefixexp COLON IDENTIFIER args .)


state 121

    (40) var -> prefixexp LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    COLON           reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    DOT             reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    STRING          reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 40 (var -> prefixexp LBRACKET expression RBRACKET .)


state 122

    (52) args -> LPAREN explist RPAREN .

    SEMICOLON       reduce using rule 52 (args -> LPAREN explist RPAREN .)
    BREAK           reduce using rule 52 (args -> LPAREN explist RPAREN .)
    GOTO            reduce using rule 52 (args -> LPAREN explist RPAREN .)
    DO              reduce using rule 52 (args -> LPAREN explist RPAREN .)
    WHILE           reduce using rule 52 (args -> LPAREN explist RPAREN .)
    REPEAT          reduce using rule 52 (args -> LPAREN explist RPAREN .)
    IF              reduce using rule 52 (args -> LPAREN explist RPAREN .)
    FOR             reduce using rule 52 (args -> LPAREN explist RPAREN .)
    FUNCTION        reduce using rule 52 (args -> LPAREN explist RPAREN .)
    LOCAL           reduce using rule 52 (args -> LPAREN explist RPAREN .)
    DOUBLECOLON     reduce using rule 52 (args -> LPAREN explist RPAREN .)
    RETURN          reduce using rule 52 (args -> LPAREN explist RPAREN .)
    IDENTIFIER      reduce using rule 52 (args -> LPAREN explist RPAREN .)
    LPAREN          reduce using rule 52 (args -> LPAREN explist RPAREN .)
    $end            reduce using rule 52 (args -> LPAREN explist RPAREN .)
    END             reduce using rule 52 (args -> LPAREN explist RPAREN .)
    UNTIL           reduce using rule 52 (args -> LPAREN explist RPAREN .)
    ELSEIF          reduce using rule 52 (args -> LPAREN explist RPAREN .)
    ELSE            reduce using rule 52 (args -> LPAREN explist RPAREN .)
    COLON           reduce using rule 52 (args -> LPAREN explist RPAREN .)
    LBRACKET        reduce using rule 52 (args -> LPAREN explist RPAREN .)
    DOT             reduce using rule 52 (args -> LPAREN explist RPAREN .)
    STRING          reduce using rule 52 (args -> LPAREN explist RPAREN .)
    LBRACE          reduce using rule 52 (args -> LPAREN explist RPAREN .)


state 123

    (63) tableconstructor -> LBRACE fieldlist RBRACE .

    SEMICOLON       reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    BREAK           reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    GOTO            reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    DO              reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    WHILE           reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    REPEAT          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    IF              reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    FOR             reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    FUNCTION        reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    LOCAL           reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    DOUBLECOLON     reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    RETURN          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    IDENTIFIER      reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    LPAREN          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    $end            reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    END             reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    UNTIL           reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    ELSEIF          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    ELSE            reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    COLON           reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    LBRACKET        reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    DOT             reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    STRING          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)
    LBRACE          reduce using rule 63 (tableconstructor -> LBRACE fieldlist RBRACE .)


state 124

    (64) fieldlist -> field fieldsep_tail .

    RBRACE          reduce using rule 64 (fieldlist -> field fieldsep_tail .)


state 125

    (65) fieldsep_tail -> fieldsep . fieldfield_tail_opt
    (67) fieldfield_tail_opt -> . fieldlist
    (68) fieldfield_tail_opt -> . empty
    (64) fieldlist -> . field fieldsep_tail
    (26) empty -> .
    (69) field -> . LBRACKET expression RBRACKET ASSIGN expression
    (70) field -> . IDENTIFIER ASSIGN expression
    (71) field -> . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    RBRACE          reduce using rule 26 (empty -> .)
    LBRACKET        shift and go to state 93
    IDENTIFIER      shift and go to state 95
    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    fieldfield_tail_opt            shift and go to state 144
    fieldlist                      shift and go to state 145
    empty                          shift and go to state 146
    field                          shift and go to state 92
    expression                     shift and go to state 94
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 126

    (66) fieldsep_tail -> empty .

    RBRACE          reduce using rule 66 (fieldsep_tail -> empty .)


state 127

    (72) fieldsep -> COMMA .

    LBRACKET        reduce using rule 72 (fieldsep -> COMMA .)
    IDENTIFIER      reduce using rule 72 (fieldsep -> COMMA .)
    FUNCTION        reduce using rule 72 (fieldsep -> COMMA .)
    INTEGER         reduce using rule 72 (fieldsep -> COMMA .)
    FLOAT           reduce using rule 72 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 72 (fieldsep -> COMMA .)
    RBRACE          reduce using rule 72 (fieldsep -> COMMA .)


state 128

    (73) fieldsep -> SEMICOLON .

    LBRACKET        reduce using rule 73 (fieldsep -> SEMICOLON .)
    IDENTIFIER      reduce using rule 73 (fieldsep -> SEMICOLON .)
    FUNCTION        reduce using rule 73 (fieldsep -> SEMICOLON .)
    INTEGER         reduce using rule 73 (fieldsep -> SEMICOLON .)
    FLOAT           reduce using rule 73 (fieldsep -> SEMICOLON .)
    LPAREN          reduce using rule 73 (fieldsep -> SEMICOLON .)
    RBRACE          reduce using rule 73 (fieldsep -> SEMICOLON .)


state 129

    (69) field -> LBRACKET expression . RBRACKET ASSIGN expression
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    RBRACKET        shift and go to state 147
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 130

    (70) field -> IDENTIFIER ASSIGN . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 148
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 131

    (14) stat -> WHILE expression DO block END .

    SEMICOLON       reduce using rule 14 (stat -> WHILE expression DO block END .)
    BREAK           reduce using rule 14 (stat -> WHILE expression DO block END .)
    GOTO            reduce using rule 14 (stat -> WHILE expression DO block END .)
    DO              reduce using rule 14 (stat -> WHILE expression DO block END .)
    WHILE           reduce using rule 14 (stat -> WHILE expression DO block END .)
    REPEAT          reduce using rule 14 (stat -> WHILE expression DO block END .)
    IF              reduce using rule 14 (stat -> WHILE expression DO block END .)
    FOR             reduce using rule 14 (stat -> WHILE expression DO block END .)
    FUNCTION        reduce using rule 14 (stat -> WHILE expression DO block END .)
    LOCAL           reduce using rule 14 (stat -> WHILE expression DO block END .)
    DOUBLECOLON     reduce using rule 14 (stat -> WHILE expression DO block END .)
    RETURN          reduce using rule 14 (stat -> WHILE expression DO block END .)
    IDENTIFIER      reduce using rule 14 (stat -> WHILE expression DO block END .)
    LPAREN          reduce using rule 14 (stat -> WHILE expression DO block END .)
    $end            reduce using rule 14 (stat -> WHILE expression DO block END .)
    END             reduce using rule 14 (stat -> WHILE expression DO block END .)
    UNTIL           reduce using rule 14 (stat -> WHILE expression DO block END .)
    ELSEIF          reduce using rule 14 (stat -> WHILE expression DO block END .)
    ELSE            reduce using rule 14 (stat -> WHILE expression DO block END .)


state 132

    (56) funcbody -> LPAREN RPAREN block . END

    END             shift and go to state 149


state 133

    (57) funcbody -> LPAREN parlist RPAREN . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 150
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 134

    (58) parlist -> namelist vararg_tail .

    RPAREN          reduce using rule 58 (parlist -> namelist vararg_tail .)


state 135

    (43) namelist -> namelist COMMA . IDENTIFIER
    (60) vararg_tail -> COMMA . VARARG

    IDENTIFIER      shift and go to state 113
    VARARG          shift and go to state 151


state 136

    (61) vararg_tail -> empty .

    RPAREN          reduce using rule 61 (vararg_tail -> empty .)


state 137

    (16) stat -> IF expression THEN block elseif_blocks . else_block END
    (18) elseif_blocks -> elseif_blocks . ELSEIF expression THEN block
    (20) else_block -> . ELSE block
    (21) else_block -> . empty
    (26) empty -> .

    ELSEIF          shift and go to state 153
    ELSE            shift and go to state 154
    END             reduce using rule 26 (empty -> .)

    else_block                     shift and go to state 152
    empty                          shift and go to state 155

state 138

    (17) elseif_blocks -> ELSEIF . expression THEN block
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 156
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 139

    (19) elseif_blocks -> empty .

    ELSEIF          reduce using rule 19 (elseif_blocks -> empty .)
    ELSE            reduce using rule 19 (elseif_blocks -> empty .)
    END             reduce using rule 19 (elseif_blocks -> empty .)


state 140

    (22) stat -> FOR IDENTIFIER ASSIGN expression COMMA . expression DO block END
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 157
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 141

    (23) stat -> FOR namelist IN explist DO . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 158
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 142

    (33) funcname_tail -> funcname_tail DOT IDENTIFIER .

    DOT             reduce using rule 33 (funcname_tail -> funcname_tail DOT IDENTIFIER .)
    COLON           reduce using rule 33 (funcname_tail -> funcname_tail DOT IDENTIFIER .)
    LPAREN          reduce using rule 33 (funcname_tail -> funcname_tail DOT IDENTIFIER .)


state 143

    (35) method_opt -> COLON IDENTIFIER .

    LPAREN          reduce using rule 35 (method_opt -> COLON IDENTIFIER .)


state 144

    (65) fieldsep_tail -> fieldsep fieldfield_tail_opt .

    RBRACE          reduce using rule 65 (fieldsep_tail -> fieldsep fieldfield_tail_opt .)


state 145

    (67) fieldfield_tail_opt -> fieldlist .

    RBRACE          reduce using rule 67 (fieldfield_tail_opt -> fieldlist .)


state 146

    (68) fieldfield_tail_opt -> empty .

    RBRACE          reduce using rule 68 (fieldfield_tail_opt -> empty .)


state 147

    (69) field -> LBRACKET expression RBRACKET . ASSIGN expression

    ASSIGN          shift and go to state 159


state 148

    (70) field -> IDENTIFIER ASSIGN expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    COMMA           reduce using rule 70 (field -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 70 (field -> IDENTIFIER ASSIGN expression .)
    RBRACE          reduce using rule 70 (field -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 149

    (56) funcbody -> LPAREN RPAREN block END .

    DO              reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    PLUS            reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    MINUS           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    THEN            reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    SEMICOLON       reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    COMMA           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    $end            reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    END             reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    UNTIL           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    ELSEIF          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    ELSE            reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    RPAREN          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    BREAK           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    GOTO            reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    WHILE           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    REPEAT          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    IF              reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    FOR             reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    FUNCTION        reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    LOCAL           reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    DOUBLECOLON     reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    RETURN          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    IDENTIFIER      reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    LPAREN          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    RBRACKET        reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)
    RBRACE          reduce using rule 56 (funcbody -> LPAREN RPAREN block END .)


state 150

    (57) funcbody -> LPAREN parlist RPAREN block . END

    END             shift and go to state 160


state 151

    (60) vararg_tail -> COMMA VARARG .

    RPAREN          reduce using rule 60 (vararg_tail -> COMMA VARARG .)


state 152

    (16) stat -> IF expression THEN block elseif_blocks else_block . END

    END             shift and go to state 161


state 153

    (18) elseif_blocks -> elseif_blocks ELSEIF . expression THEN block
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 162
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 154

    (20) else_block -> ELSE . block
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 163
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 155

    (21) else_block -> empty .

    END             reduce using rule 21 (else_block -> empty .)


state 156

    (17) elseif_blocks -> ELSEIF expression . THEN block
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            shift and go to state 164
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 157

    (22) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression . DO block END
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    DO              shift and go to state 165
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 158

    (23) stat -> FOR namelist IN explist DO block . END

    END             shift and go to state 166


state 159

    (69) field -> LBRACKET expression RBRACKET ASSIGN . expression
    (55) expression -> . FUNCTION funcbody
    (76) expression -> . expression PLUS term
    (77) expression -> . expression MINUS term
    (81) expression -> . term
    (78) term -> . term TIMES factor
    (79) term -> . term DIVIDE factor
    (80) term -> . term POWER factor
    (82) term -> . factor
    (83) factor -> . INTEGER
    (84) factor -> . FLOAT
    (85) factor -> . LPAREN expression RPAREN

    FUNCTION        shift and go to state 33
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 167
    term                           shift and go to state 34
    factor                         shift and go to state 35

state 160

    (57) funcbody -> LPAREN parlist RPAREN block END .

    DO              reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    PLUS            reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    MINUS           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    THEN            reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    SEMICOLON       reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    COMMA           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    $end            reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    END             reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    UNTIL           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    ELSEIF          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    ELSE            reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    RPAREN          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    BREAK           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    GOTO            reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    WHILE           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    REPEAT          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    IF              reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    FOR             reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    FUNCTION        reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    LOCAL           reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    DOUBLECOLON     reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    RETURN          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    IDENTIFIER      reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    LPAREN          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    RBRACKET        reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)
    RBRACE          reduce using rule 57 (funcbody -> LPAREN parlist RPAREN block END .)


state 161

    (16) stat -> IF expression THEN block elseif_blocks else_block END .

    SEMICOLON       reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    BREAK           reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    GOTO            reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    DO              reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    WHILE           reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    REPEAT          reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    IF              reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    FOR             reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    FUNCTION        reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    LOCAL           reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    DOUBLECOLON     reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    RETURN          reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    IDENTIFIER      reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    LPAREN          reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    $end            reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    END             reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    UNTIL           reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    ELSEIF          reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)
    ELSE            reduce using rule 16 (stat -> IF expression THEN block elseif_blocks else_block END .)


state 162

    (18) elseif_blocks -> elseif_blocks ELSEIF expression . THEN block
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    THEN            shift and go to state 168
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 163

    (20) else_block -> ELSE block .

    END             reduce using rule 20 (else_block -> ELSE block .)


state 164

    (17) elseif_blocks -> ELSEIF expression THEN . block
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    ELSEIF          reduce using rule 26 (empty -> .)
    ELSE            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 169
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 165

    (22) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO . block END
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 170
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 166

    (23) stat -> FOR namelist IN explist DO block END .

    SEMICOLON       reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    GOTO            reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    DO              reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    WHILE           reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    FUNCTION        reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    LOCAL           reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    DOUBLECOLON     reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    RETURN          reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    IDENTIFIER      reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    LPAREN          reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    $end            reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    END             reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    UNTIL           reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    ELSEIF          reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)
    ELSE            reduce using rule 23 (stat -> FOR namelist IN explist DO block END .)


state 167

    (69) field -> LBRACKET expression RBRACKET ASSIGN expression .
    (76) expression -> expression . PLUS term
    (77) expression -> expression . MINUS term

    COMMA           reduce using rule 69 (field -> LBRACKET expression RBRACKET ASSIGN expression .)
    SEMICOLON       reduce using rule 69 (field -> LBRACKET expression RBRACKET ASSIGN expression .)
    RBRACE          reduce using rule 69 (field -> LBRACKET expression RBRACKET ASSIGN expression .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66


state 168

    (18) elseif_blocks -> elseif_blocks ELSEIF expression THEN . block
    (3) block -> . stat_list retstat_opt
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . empty
    (26) empty -> .

    SEMICOLON       reduce using rule 26 (empty -> .)
    BREAK           reduce using rule 26 (empty -> .)
    GOTO            reduce using rule 26 (empty -> .)
    DO              reduce using rule 26 (empty -> .)
    WHILE           reduce using rule 26 (empty -> .)
    REPEAT          reduce using rule 26 (empty -> .)
    IF              reduce using rule 26 (empty -> .)
    FOR             reduce using rule 26 (empty -> .)
    FUNCTION        reduce using rule 26 (empty -> .)
    LOCAL           reduce using rule 26 (empty -> .)
    DOUBLECOLON     reduce using rule 26 (empty -> .)
    RETURN          reduce using rule 26 (empty -> .)
    IDENTIFIER      reduce using rule 26 (empty -> .)
    LPAREN          reduce using rule 26 (empty -> .)
    ELSEIF          reduce using rule 26 (empty -> .)
    ELSE            reduce using rule 26 (empty -> .)
    END             reduce using rule 26 (empty -> .)

    block                          shift and go to state 171
    stat_list                      shift and go to state 4
    empty                          shift and go to state 5

state 169

    (17) elseif_blocks -> ELSEIF expression THEN block .

    ELSEIF          reduce using rule 17 (elseif_blocks -> ELSEIF expression THEN block .)
    ELSE            reduce using rule 17 (elseif_blocks -> ELSEIF expression THEN block .)
    END             reduce using rule 17 (elseif_blocks -> ELSEIF expression THEN block .)


state 170

    (22) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block . END

    END             shift and go to state 172


state 171

    (18) elseif_blocks -> elseif_blocks ELSEIF expression THEN block .

    ELSEIF          reduce using rule 18 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)
    ELSE            reduce using rule 18 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)
    END             reduce using rule 18 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)


state 172

    (22) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .

    SEMICOLON       reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    BREAK           reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    GOTO            reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    DO              reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    WHILE           reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    REPEAT          reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    IF              reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    FOR             reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    FUNCTION        reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    LOCAL           reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    DOUBLECOLON     reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    RETURN          reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    IDENTIFIER      reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    LPAREN          reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    $end            reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    END             reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    UNTIL           reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    ELSEIF          reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    ELSE            reduce using rule 22 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSEIF in state 110 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (stat -> functioncall)
WARNING: rejected rule (prefixexp -> functioncall) in state 12
