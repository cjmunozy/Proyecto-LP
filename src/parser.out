Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    CONCAT
    DIVIDEASSIGN
    DOUBLECOLON
    EQUALS
    FALSE
    FUNCTION
    GOTO
    GREATER
    GREATEREQUALS
    LBRACE
    LEN
    LOCAL
    LOWER
    LOWEREQUALS
    MINUSASSIGN
    MOD
    MODASSIGN
    NEQUALS
    NIL
    NOT
    OR
    PLUSASSIGN
    POWERASSIGN
    RBRACE
    RETURN
    TIMESASSIGN
    TRUE

Grammar

Rule 0     S' -> start
Rule 1     start -> chunk
Rule 2     chunk -> block
Rule 3     block -> stat_list
Rule 4     stat_list -> stat_list stat
Rule 5     stat_list -> stat
Rule 6     stat -> SEMICOLON
Rule 7     stat -> functioncall
Rule 8     stat -> BREAK
Rule 9     stat -> expression
Rule 10    stat -> DO block END
Rule 11    stat -> WHILE expression DO block END
Rule 12    stat -> REPEAT block UNTIL expression
Rule 13    stat -> IF expression THEN block elseif_blocks else_block END
Rule 14    elseif_blocks -> ELSEIF expression THEN block
Rule 15    elseif_blocks -> elseif_blocks ELSEIF expression THEN block
Rule 16    elseif_blocks -> empty
Rule 17    else_block -> ELSE block
Rule 18    else_block -> empty
Rule 19    stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
Rule 20    stat -> FOR namelist IN explist DO block END
Rule 21    empty -> <empty>
Rule 22    funcname -> IDENTIFIER funcname_tail method_opt
Rule 23    funcname_tail -> funcname_tail DOT IDENTIFIER
Rule 24    funcname_tail -> empty
Rule 25    method_opt -> COLON IDENTIFIER
Rule 26    method_opt -> empty
Rule 27    varlist -> varlist COMMA var
Rule 28    varlist -> empty
Rule 29    var -> IDENTIFIER
Rule 30    var -> prefixexp LBRACKET expression RBRACKET
Rule 31    var -> prefixexp DOT IDENTIFIER
Rule 32    namelist -> namelist COMMA IDENTIFIER
Rule 33    namelist -> IDENTIFIER
Rule 34    explist -> explist COMMA expression
Rule 35    explist -> expression
Rule 36    prefixexp -> var
Rule 37    prefixexp -> functioncall
Rule 38    prefixexp -> LPAREN expression RPAREN
Rule 39    functioncall -> prefixexp args
Rule 40    functioncall -> prefixexp COLON IDENTIFIER args
Rule 41    args -> LPAREN RPAREN
Rule 42    args -> LPAREN explist RPAREN
Rule 43    args -> STRING
Rule 44    statement -> input
Rule 45    statement -> print
Rule 46    expression -> expression PLUS term
Rule 47    expression -> expression MINUS term
Rule 48    term -> term TIMES factor
Rule 49    term -> term DIVIDE factor
Rule 50    term -> term POWER factor
Rule 51    expression -> term
Rule 52    term -> factor
Rule 53    factor -> INTEGER
Rule 54    factor -> FLOAT
Rule 55    factor -> LPAREN expression RPAREN
Rule 56    print -> PRINT LPAREN expression RPAREN
Rule 57    print -> PRINT LPAREN STRING RPAREN
Rule 58    input -> INPUT LPAREN RPAREN

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 19
BREAK                : 8
COLON                : 25 40
COMMA                : 19 27 32 34
CONCAT               : 
DIVIDE               : 49
DIVIDEASSIGN         : 
DO                   : 10 11 19 20
DOT                  : 23 31
DOUBLECOLON          : 
ELSE                 : 17
ELSEIF               : 14 15
END                  : 10 11 13 19 20
EQUALS               : 
FALSE                : 
FLOAT                : 54
FOR                  : 19 20
FUNCTION             : 
GOTO                 : 
GREATER              : 
GREATEREQUALS        : 
IDENTIFIER           : 19 22 23 25 29 31 32 33 40
IF                   : 13
IN                   : 20
INPUT                : 58
INTEGER              : 53
LBRACE               : 
LBRACKET             : 30
LEN                  : 
LOCAL                : 
LOWER                : 
LOWEREQUALS          : 
LPAREN               : 38 41 42 55 56 57 58
MINUS                : 47
MINUSASSIGN          : 
MOD                  : 
MODASSIGN            : 
NEQUALS              : 
NIL                  : 
NOT                  : 
OR                   : 
PLUS                 : 46
PLUSASSIGN           : 
POWER                : 50
POWERASSIGN          : 
PRINT                : 56 57
RBRACE               : 
RBRACKET             : 30
REPEAT               : 12
RETURN               : 
RPAREN               : 38 41 42 55 56 57 58
SEMICOLON            : 6
STRING               : 43 57
THEN                 : 13 14 15
TIMES                : 48
TIMESASSIGN          : 
TRUE                 : 
UNTIL                : 12
WHILE                : 11
error                : 

Nonterminals, with rules where they appear

args                 : 39 40
block                : 2 10 11 12 13 14 15 17 19 20
chunk                : 1
else_block           : 13
elseif_blocks        : 13 15
empty                : 16 18 24 26 28
explist              : 20 34 42
expression           : 9 11 12 13 14 15 19 19 30 34 35 38 46 47 55 56
factor               : 48 49 50 52
funcname             : 
funcname_tail        : 22 23
functioncall         : 7 37
input                : 44
method_opt           : 22
namelist             : 20 32
prefixexp            : 30 31 39 40
print                : 45
start                : 0
stat                 : 4 5
stat_list            : 3 4
statement            : 
term                 : 46 47 48 49 50 51
var                  : 27 36
varlist              : 27

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . chunk
    (2) chunk -> . block
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    start                          shift and go to state 1
    chunk                          shift and go to state 2
    block                          shift and go to state 3
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    expression                     shift and go to state 9
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 1

    (0) S' -> start .



state 2

    (1) start -> chunk .

    $end            reduce using rule 1 (start -> chunk .)


state 3

    (2) chunk -> block .

    $end            reduce using rule 2 (chunk -> block .)


state 4

    (3) block -> stat_list .
    (4) stat_list -> stat_list . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    $end            reduce using rule 3 (block -> stat_list .)
    END             reduce using rule 3 (block -> stat_list .)
    UNTIL           reduce using rule 3 (block -> stat_list .)
    ELSEIF          reduce using rule 3 (block -> stat_list .)
    ELSE            reduce using rule 3 (block -> stat_list .)
    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    stat                           shift and go to state 23
    functioncall                   shift and go to state 7
    expression                     shift and go to state 9
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 5

    (5) stat_list -> stat .

    SEMICOLON       reduce using rule 5 (stat_list -> stat .)
    BREAK           reduce using rule 5 (stat_list -> stat .)
    DO              reduce using rule 5 (stat_list -> stat .)
    WHILE           reduce using rule 5 (stat_list -> stat .)
    REPEAT          reduce using rule 5 (stat_list -> stat .)
    IF              reduce using rule 5 (stat_list -> stat .)
    FOR             reduce using rule 5 (stat_list -> stat .)
    LPAREN          reduce using rule 5 (stat_list -> stat .)
    IDENTIFIER      reduce using rule 5 (stat_list -> stat .)
    INTEGER         reduce using rule 5 (stat_list -> stat .)
    FLOAT           reduce using rule 5 (stat_list -> stat .)
    $end            reduce using rule 5 (stat_list -> stat .)
    END             reduce using rule 5 (stat_list -> stat .)
    UNTIL           reduce using rule 5 (stat_list -> stat .)
    ELSEIF          reduce using rule 5 (stat_list -> stat .)
    ELSE            reduce using rule 5 (stat_list -> stat .)


state 6

    (6) stat -> SEMICOLON .

    SEMICOLON       reduce using rule 6 (stat -> SEMICOLON .)
    BREAK           reduce using rule 6 (stat -> SEMICOLON .)
    DO              reduce using rule 6 (stat -> SEMICOLON .)
    WHILE           reduce using rule 6 (stat -> SEMICOLON .)
    REPEAT          reduce using rule 6 (stat -> SEMICOLON .)
    IF              reduce using rule 6 (stat -> SEMICOLON .)
    FOR             reduce using rule 6 (stat -> SEMICOLON .)
    LPAREN          reduce using rule 6 (stat -> SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (stat -> SEMICOLON .)
    INTEGER         reduce using rule 6 (stat -> SEMICOLON .)
    FLOAT           reduce using rule 6 (stat -> SEMICOLON .)
    $end            reduce using rule 6 (stat -> SEMICOLON .)
    END             reduce using rule 6 (stat -> SEMICOLON .)
    UNTIL           reduce using rule 6 (stat -> SEMICOLON .)
    ELSEIF          reduce using rule 6 (stat -> SEMICOLON .)
    ELSE            reduce using rule 6 (stat -> SEMICOLON .)


state 7

    (7) stat -> functioncall .
    (37) prefixexp -> functioncall .

  ! reduce/reduce conflict for LPAREN resolved using rule 7 (stat -> functioncall .)
    SEMICOLON       reduce using rule 7 (stat -> functioncall .)
    BREAK           reduce using rule 7 (stat -> functioncall .)
    DO              reduce using rule 7 (stat -> functioncall .)
    WHILE           reduce using rule 7 (stat -> functioncall .)
    REPEAT          reduce using rule 7 (stat -> functioncall .)
    IF              reduce using rule 7 (stat -> functioncall .)
    FOR             reduce using rule 7 (stat -> functioncall .)
    LPAREN          reduce using rule 7 (stat -> functioncall .)
    IDENTIFIER      reduce using rule 7 (stat -> functioncall .)
    INTEGER         reduce using rule 7 (stat -> functioncall .)
    FLOAT           reduce using rule 7 (stat -> functioncall .)
    $end            reduce using rule 7 (stat -> functioncall .)
    END             reduce using rule 7 (stat -> functioncall .)
    UNTIL           reduce using rule 7 (stat -> functioncall .)
    ELSEIF          reduce using rule 7 (stat -> functioncall .)
    ELSE            reduce using rule 7 (stat -> functioncall .)
    COLON           reduce using rule 37 (prefixexp -> functioncall .)
    LBRACKET        reduce using rule 37 (prefixexp -> functioncall .)
    DOT             reduce using rule 37 (prefixexp -> functioncall .)
    STRING          reduce using rule 37 (prefixexp -> functioncall .)

  ! LPAREN          [ reduce using rule 37 (prefixexp -> functioncall .) ]


state 8

    (8) stat -> BREAK .

    SEMICOLON       reduce using rule 8 (stat -> BREAK .)
    BREAK           reduce using rule 8 (stat -> BREAK .)
    DO              reduce using rule 8 (stat -> BREAK .)
    WHILE           reduce using rule 8 (stat -> BREAK .)
    REPEAT          reduce using rule 8 (stat -> BREAK .)
    IF              reduce using rule 8 (stat -> BREAK .)
    FOR             reduce using rule 8 (stat -> BREAK .)
    LPAREN          reduce using rule 8 (stat -> BREAK .)
    IDENTIFIER      reduce using rule 8 (stat -> BREAK .)
    INTEGER         reduce using rule 8 (stat -> BREAK .)
    FLOAT           reduce using rule 8 (stat -> BREAK .)
    $end            reduce using rule 8 (stat -> BREAK .)
    END             reduce using rule 8 (stat -> BREAK .)
    UNTIL           reduce using rule 8 (stat -> BREAK .)
    ELSEIF          reduce using rule 8 (stat -> BREAK .)
    ELSE            reduce using rule 8 (stat -> BREAK .)


state 9

    (9) stat -> expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 9 (stat -> expression .)
    BREAK           reduce using rule 9 (stat -> expression .)
    DO              reduce using rule 9 (stat -> expression .)
    WHILE           reduce using rule 9 (stat -> expression .)
    REPEAT          reduce using rule 9 (stat -> expression .)
    IF              reduce using rule 9 (stat -> expression .)
    FOR             reduce using rule 9 (stat -> expression .)
    LPAREN          reduce using rule 9 (stat -> expression .)
    IDENTIFIER      reduce using rule 9 (stat -> expression .)
    INTEGER         reduce using rule 9 (stat -> expression .)
    FLOAT           reduce using rule 9 (stat -> expression .)
    $end            reduce using rule 9 (stat -> expression .)
    END             reduce using rule 9 (stat -> expression .)
    UNTIL           reduce using rule 9 (stat -> expression .)
    ELSEIF          reduce using rule 9 (stat -> expression .)
    ELSE            reduce using rule 9 (stat -> expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 10

    (10) stat -> DO . block END
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    block                          shift and go to state 26
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    expression                     shift and go to state 9
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 11

    (11) stat -> WHILE . expression DO block END
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 27
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 12

    (12) stat -> REPEAT . block UNTIL expression
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    block                          shift and go to state 29
    expression                     shift and go to state 9
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 13

    (13) stat -> IF . expression THEN block elseif_blocks else_block END
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 30
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 14

    (19) stat -> FOR . IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> FOR . namelist IN explist DO block END
    (32) namelist -> . namelist COMMA IDENTIFIER
    (33) namelist -> . IDENTIFIER

    IDENTIFIER      shift and go to state 31

    namelist                       shift and go to state 32

state 15

    (29) var -> IDENTIFIER .

    COLON           reduce using rule 29 (var -> IDENTIFIER .)
    LBRACKET        reduce using rule 29 (var -> IDENTIFIER .)
    DOT             reduce using rule 29 (var -> IDENTIFIER .)
    LPAREN          reduce using rule 29 (var -> IDENTIFIER .)
    STRING          reduce using rule 29 (var -> IDENTIFIER .)


state 16

    (39) functioncall -> prefixexp . args
    (40) functioncall -> prefixexp . COLON IDENTIFIER args
    (30) var -> prefixexp . LBRACKET expression RBRACKET
    (31) var -> prefixexp . DOT IDENTIFIER
    (41) args -> . LPAREN RPAREN
    (42) args -> . LPAREN explist RPAREN
    (43) args -> . STRING

    COLON           shift and go to state 34
    LBRACKET        shift and go to state 35
    DOT             shift and go to state 36
    LPAREN          shift and go to state 37
    STRING          shift and go to state 38

    args                           shift and go to state 33

state 17

    (51) expression -> term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor
    (50) term -> term . POWER factor

    PLUS            reduce using rule 51 (expression -> term .)
    MINUS           reduce using rule 51 (expression -> term .)
    SEMICOLON       reduce using rule 51 (expression -> term .)
    BREAK           reduce using rule 51 (expression -> term .)
    DO              reduce using rule 51 (expression -> term .)
    WHILE           reduce using rule 51 (expression -> term .)
    REPEAT          reduce using rule 51 (expression -> term .)
    IF              reduce using rule 51 (expression -> term .)
    FOR             reduce using rule 51 (expression -> term .)
    LPAREN          reduce using rule 51 (expression -> term .)
    IDENTIFIER      reduce using rule 51 (expression -> term .)
    INTEGER         reduce using rule 51 (expression -> term .)
    FLOAT           reduce using rule 51 (expression -> term .)
    $end            reduce using rule 51 (expression -> term .)
    END             reduce using rule 51 (expression -> term .)
    UNTIL           reduce using rule 51 (expression -> term .)
    ELSEIF          reduce using rule 51 (expression -> term .)
    ELSE            reduce using rule 51 (expression -> term .)
    THEN            reduce using rule 51 (expression -> term .)
    RPAREN          reduce using rule 51 (expression -> term .)
    RBRACKET        reduce using rule 51 (expression -> term .)
    COMMA           reduce using rule 51 (expression -> term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 18

    (36) prefixexp -> var .

    COLON           reduce using rule 36 (prefixexp -> var .)
    LBRACKET        reduce using rule 36 (prefixexp -> var .)
    DOT             reduce using rule 36 (prefixexp -> var .)
    LPAREN          reduce using rule 36 (prefixexp -> var .)
    STRING          reduce using rule 36 (prefixexp -> var .)


state 19

    (38) prefixexp -> LPAREN . expression RPAREN
    (55) factor -> LPAREN . expression RPAREN
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 42
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 20

    (52) term -> factor .

    TIMES           reduce using rule 52 (term -> factor .)
    DIVIDE          reduce using rule 52 (term -> factor .)
    POWER           reduce using rule 52 (term -> factor .)
    PLUS            reduce using rule 52 (term -> factor .)
    MINUS           reduce using rule 52 (term -> factor .)
    SEMICOLON       reduce using rule 52 (term -> factor .)
    BREAK           reduce using rule 52 (term -> factor .)
    DO              reduce using rule 52 (term -> factor .)
    WHILE           reduce using rule 52 (term -> factor .)
    REPEAT          reduce using rule 52 (term -> factor .)
    IF              reduce using rule 52 (term -> factor .)
    FOR             reduce using rule 52 (term -> factor .)
    LPAREN          reduce using rule 52 (term -> factor .)
    IDENTIFIER      reduce using rule 52 (term -> factor .)
    INTEGER         reduce using rule 52 (term -> factor .)
    FLOAT           reduce using rule 52 (term -> factor .)
    $end            reduce using rule 52 (term -> factor .)
    END             reduce using rule 52 (term -> factor .)
    UNTIL           reduce using rule 52 (term -> factor .)
    ELSEIF          reduce using rule 52 (term -> factor .)
    ELSE            reduce using rule 52 (term -> factor .)
    THEN            reduce using rule 52 (term -> factor .)
    RPAREN          reduce using rule 52 (term -> factor .)
    RBRACKET        reduce using rule 52 (term -> factor .)
    COMMA           reduce using rule 52 (term -> factor .)


state 21

    (53) factor -> INTEGER .

    TIMES           reduce using rule 53 (factor -> INTEGER .)
    DIVIDE          reduce using rule 53 (factor -> INTEGER .)
    POWER           reduce using rule 53 (factor -> INTEGER .)
    PLUS            reduce using rule 53 (factor -> INTEGER .)
    MINUS           reduce using rule 53 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 53 (factor -> INTEGER .)
    BREAK           reduce using rule 53 (factor -> INTEGER .)
    DO              reduce using rule 53 (factor -> INTEGER .)
    WHILE           reduce using rule 53 (factor -> INTEGER .)
    REPEAT          reduce using rule 53 (factor -> INTEGER .)
    IF              reduce using rule 53 (factor -> INTEGER .)
    FOR             reduce using rule 53 (factor -> INTEGER .)
    LPAREN          reduce using rule 53 (factor -> INTEGER .)
    IDENTIFIER      reduce using rule 53 (factor -> INTEGER .)
    INTEGER         reduce using rule 53 (factor -> INTEGER .)
    FLOAT           reduce using rule 53 (factor -> INTEGER .)
    $end            reduce using rule 53 (factor -> INTEGER .)
    END             reduce using rule 53 (factor -> INTEGER .)
    UNTIL           reduce using rule 53 (factor -> INTEGER .)
    ELSEIF          reduce using rule 53 (factor -> INTEGER .)
    ELSE            reduce using rule 53 (factor -> INTEGER .)
    THEN            reduce using rule 53 (factor -> INTEGER .)
    RPAREN          reduce using rule 53 (factor -> INTEGER .)
    RBRACKET        reduce using rule 53 (factor -> INTEGER .)
    COMMA           reduce using rule 53 (factor -> INTEGER .)


state 22

    (54) factor -> FLOAT .

    TIMES           reduce using rule 54 (factor -> FLOAT .)
    DIVIDE          reduce using rule 54 (factor -> FLOAT .)
    POWER           reduce using rule 54 (factor -> FLOAT .)
    PLUS            reduce using rule 54 (factor -> FLOAT .)
    MINUS           reduce using rule 54 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 54 (factor -> FLOAT .)
    BREAK           reduce using rule 54 (factor -> FLOAT .)
    DO              reduce using rule 54 (factor -> FLOAT .)
    WHILE           reduce using rule 54 (factor -> FLOAT .)
    REPEAT          reduce using rule 54 (factor -> FLOAT .)
    IF              reduce using rule 54 (factor -> FLOAT .)
    FOR             reduce using rule 54 (factor -> FLOAT .)
    LPAREN          reduce using rule 54 (factor -> FLOAT .)
    IDENTIFIER      reduce using rule 54 (factor -> FLOAT .)
    INTEGER         reduce using rule 54 (factor -> FLOAT .)
    FLOAT           reduce using rule 54 (factor -> FLOAT .)
    $end            reduce using rule 54 (factor -> FLOAT .)
    END             reduce using rule 54 (factor -> FLOAT .)
    UNTIL           reduce using rule 54 (factor -> FLOAT .)
    ELSEIF          reduce using rule 54 (factor -> FLOAT .)
    ELSE            reduce using rule 54 (factor -> FLOAT .)
    THEN            reduce using rule 54 (factor -> FLOAT .)
    RPAREN          reduce using rule 54 (factor -> FLOAT .)
    RBRACKET        reduce using rule 54 (factor -> FLOAT .)
    COMMA           reduce using rule 54 (factor -> FLOAT .)


state 23

    (4) stat_list -> stat_list stat .

    SEMICOLON       reduce using rule 4 (stat_list -> stat_list stat .)
    BREAK           reduce using rule 4 (stat_list -> stat_list stat .)
    DO              reduce using rule 4 (stat_list -> stat_list stat .)
    WHILE           reduce using rule 4 (stat_list -> stat_list stat .)
    REPEAT          reduce using rule 4 (stat_list -> stat_list stat .)
    IF              reduce using rule 4 (stat_list -> stat_list stat .)
    FOR             reduce using rule 4 (stat_list -> stat_list stat .)
    LPAREN          reduce using rule 4 (stat_list -> stat_list stat .)
    IDENTIFIER      reduce using rule 4 (stat_list -> stat_list stat .)
    INTEGER         reduce using rule 4 (stat_list -> stat_list stat .)
    FLOAT           reduce using rule 4 (stat_list -> stat_list stat .)
    $end            reduce using rule 4 (stat_list -> stat_list stat .)
    END             reduce using rule 4 (stat_list -> stat_list stat .)
    UNTIL           reduce using rule 4 (stat_list -> stat_list stat .)
    ELSEIF          reduce using rule 4 (stat_list -> stat_list stat .)
    ELSE            reduce using rule 4 (stat_list -> stat_list stat .)


state 24

    (46) expression -> expression PLUS . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    term                           shift and go to state 43
    factor                         shift and go to state 20

state 25

    (47) expression -> expression MINUS . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    term                           shift and go to state 44
    factor                         shift and go to state 20

state 26

    (10) stat -> DO block . END

    END             shift and go to state 45


state 27

    (11) stat -> WHILE expression . DO block END
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    DO              shift and go to state 46
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 28

    (55) factor -> LPAREN . expression RPAREN
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 47
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 29

    (12) stat -> REPEAT block . UNTIL expression

    UNTIL           shift and go to state 48


state 30

    (13) stat -> IF expression . THEN block elseif_blocks else_block END
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    THEN            shift and go to state 49
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 31

    (19) stat -> FOR IDENTIFIER . ASSIGN expression COMMA expression DO block END
    (33) namelist -> IDENTIFIER .

    ASSIGN          shift and go to state 50
    IN              reduce using rule 33 (namelist -> IDENTIFIER .)
    COMMA           reduce using rule 33 (namelist -> IDENTIFIER .)


state 32

    (20) stat -> FOR namelist . IN explist DO block END
    (32) namelist -> namelist . COMMA IDENTIFIER

    IN              shift and go to state 51
    COMMA           shift and go to state 52


state 33

    (39) functioncall -> prefixexp args .

    SEMICOLON       reduce using rule 39 (functioncall -> prefixexp args .)
    BREAK           reduce using rule 39 (functioncall -> prefixexp args .)
    DO              reduce using rule 39 (functioncall -> prefixexp args .)
    WHILE           reduce using rule 39 (functioncall -> prefixexp args .)
    REPEAT          reduce using rule 39 (functioncall -> prefixexp args .)
    IF              reduce using rule 39 (functioncall -> prefixexp args .)
    FOR             reduce using rule 39 (functioncall -> prefixexp args .)
    LPAREN          reduce using rule 39 (functioncall -> prefixexp args .)
    IDENTIFIER      reduce using rule 39 (functioncall -> prefixexp args .)
    INTEGER         reduce using rule 39 (functioncall -> prefixexp args .)
    FLOAT           reduce using rule 39 (functioncall -> prefixexp args .)
    $end            reduce using rule 39 (functioncall -> prefixexp args .)
    COLON           reduce using rule 39 (functioncall -> prefixexp args .)
    LBRACKET        reduce using rule 39 (functioncall -> prefixexp args .)
    DOT             reduce using rule 39 (functioncall -> prefixexp args .)
    STRING          reduce using rule 39 (functioncall -> prefixexp args .)
    END             reduce using rule 39 (functioncall -> prefixexp args .)
    UNTIL           reduce using rule 39 (functioncall -> prefixexp args .)
    ELSEIF          reduce using rule 39 (functioncall -> prefixexp args .)
    ELSE            reduce using rule 39 (functioncall -> prefixexp args .)


state 34

    (40) functioncall -> prefixexp COLON . IDENTIFIER args

    IDENTIFIER      shift and go to state 53


state 35

    (30) var -> prefixexp LBRACKET . expression RBRACKET
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 54
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 36

    (31) var -> prefixexp DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 55


state 37

    (41) args -> LPAREN . RPAREN
    (42) args -> LPAREN . explist RPAREN
    (34) explist -> . explist COMMA expression
    (35) explist -> . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    RPAREN          shift and go to state 56
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    explist                        shift and go to state 57
    expression                     shift and go to state 58
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 38

    (43) args -> STRING .

    SEMICOLON       reduce using rule 43 (args -> STRING .)
    BREAK           reduce using rule 43 (args -> STRING .)
    DO              reduce using rule 43 (args -> STRING .)
    WHILE           reduce using rule 43 (args -> STRING .)
    REPEAT          reduce using rule 43 (args -> STRING .)
    IF              reduce using rule 43 (args -> STRING .)
    FOR             reduce using rule 43 (args -> STRING .)
    LPAREN          reduce using rule 43 (args -> STRING .)
    IDENTIFIER      reduce using rule 43 (args -> STRING .)
    INTEGER         reduce using rule 43 (args -> STRING .)
    FLOAT           reduce using rule 43 (args -> STRING .)
    $end            reduce using rule 43 (args -> STRING .)
    COLON           reduce using rule 43 (args -> STRING .)
    LBRACKET        reduce using rule 43 (args -> STRING .)
    DOT             reduce using rule 43 (args -> STRING .)
    STRING          reduce using rule 43 (args -> STRING .)
    END             reduce using rule 43 (args -> STRING .)
    UNTIL           reduce using rule 43 (args -> STRING .)
    ELSEIF          reduce using rule 43 (args -> STRING .)
    ELSE            reduce using rule 43 (args -> STRING .)


state 39

    (48) term -> term TIMES . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    factor                         shift and go to state 59

state 40

    (49) term -> term DIVIDE . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    factor                         shift and go to state 60

state 41

    (50) term -> term POWER . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    factor                         shift and go to state 61

state 42

    (38) prefixexp -> LPAREN expression . RPAREN
    (55) factor -> LPAREN expression . RPAREN
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    RPAREN          shift and go to state 62
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 43

    (46) expression -> expression PLUS term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor
    (50) term -> term . POWER factor

    PLUS            reduce using rule 46 (expression -> expression PLUS term .)
    MINUS           reduce using rule 46 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 46 (expression -> expression PLUS term .)
    BREAK           reduce using rule 46 (expression -> expression PLUS term .)
    DO              reduce using rule 46 (expression -> expression PLUS term .)
    WHILE           reduce using rule 46 (expression -> expression PLUS term .)
    REPEAT          reduce using rule 46 (expression -> expression PLUS term .)
    IF              reduce using rule 46 (expression -> expression PLUS term .)
    FOR             reduce using rule 46 (expression -> expression PLUS term .)
    LPAREN          reduce using rule 46 (expression -> expression PLUS term .)
    IDENTIFIER      reduce using rule 46 (expression -> expression PLUS term .)
    INTEGER         reduce using rule 46 (expression -> expression PLUS term .)
    FLOAT           reduce using rule 46 (expression -> expression PLUS term .)
    $end            reduce using rule 46 (expression -> expression PLUS term .)
    END             reduce using rule 46 (expression -> expression PLUS term .)
    UNTIL           reduce using rule 46 (expression -> expression PLUS term .)
    ELSEIF          reduce using rule 46 (expression -> expression PLUS term .)
    ELSE            reduce using rule 46 (expression -> expression PLUS term .)
    THEN            reduce using rule 46 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 46 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 46 (expression -> expression PLUS term .)
    COMMA           reduce using rule 46 (expression -> expression PLUS term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 44

    (47) expression -> expression MINUS term .
    (48) term -> term . TIMES factor
    (49) term -> term . DIVIDE factor
    (50) term -> term . POWER factor

    PLUS            reduce using rule 47 (expression -> expression MINUS term .)
    MINUS           reduce using rule 47 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 47 (expression -> expression MINUS term .)
    BREAK           reduce using rule 47 (expression -> expression MINUS term .)
    DO              reduce using rule 47 (expression -> expression MINUS term .)
    WHILE           reduce using rule 47 (expression -> expression MINUS term .)
    REPEAT          reduce using rule 47 (expression -> expression MINUS term .)
    IF              reduce using rule 47 (expression -> expression MINUS term .)
    FOR             reduce using rule 47 (expression -> expression MINUS term .)
    LPAREN          reduce using rule 47 (expression -> expression MINUS term .)
    IDENTIFIER      reduce using rule 47 (expression -> expression MINUS term .)
    INTEGER         reduce using rule 47 (expression -> expression MINUS term .)
    FLOAT           reduce using rule 47 (expression -> expression MINUS term .)
    $end            reduce using rule 47 (expression -> expression MINUS term .)
    END             reduce using rule 47 (expression -> expression MINUS term .)
    UNTIL           reduce using rule 47 (expression -> expression MINUS term .)
    ELSEIF          reduce using rule 47 (expression -> expression MINUS term .)
    ELSE            reduce using rule 47 (expression -> expression MINUS term .)
    THEN            reduce using rule 47 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 47 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 47 (expression -> expression MINUS term .)
    COMMA           reduce using rule 47 (expression -> expression MINUS term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 45

    (10) stat -> DO block END .

    SEMICOLON       reduce using rule 10 (stat -> DO block END .)
    BREAK           reduce using rule 10 (stat -> DO block END .)
    DO              reduce using rule 10 (stat -> DO block END .)
    WHILE           reduce using rule 10 (stat -> DO block END .)
    REPEAT          reduce using rule 10 (stat -> DO block END .)
    IF              reduce using rule 10 (stat -> DO block END .)
    FOR             reduce using rule 10 (stat -> DO block END .)
    LPAREN          reduce using rule 10 (stat -> DO block END .)
    IDENTIFIER      reduce using rule 10 (stat -> DO block END .)
    INTEGER         reduce using rule 10 (stat -> DO block END .)
    FLOAT           reduce using rule 10 (stat -> DO block END .)
    $end            reduce using rule 10 (stat -> DO block END .)
    END             reduce using rule 10 (stat -> DO block END .)
    UNTIL           reduce using rule 10 (stat -> DO block END .)
    ELSEIF          reduce using rule 10 (stat -> DO block END .)
    ELSE            reduce using rule 10 (stat -> DO block END .)


state 46

    (11) stat -> WHILE expression DO . block END
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    expression                     shift and go to state 9
    block                          shift and go to state 63
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 47

    (55) factor -> LPAREN expression . RPAREN
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    RPAREN          shift and go to state 64
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 48

    (12) stat -> REPEAT block UNTIL . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 65
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 49

    (13) stat -> IF expression THEN . block elseif_blocks else_block END
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    expression                     shift and go to state 9
    block                          shift and go to state 66
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 50

    (19) stat -> FOR IDENTIFIER ASSIGN . expression COMMA expression DO block END
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 67
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 51

    (20) stat -> FOR namelist IN . explist DO block END
    (34) explist -> . explist COMMA expression
    (35) explist -> . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    explist                        shift and go to state 68
    expression                     shift and go to state 58
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 52

    (32) namelist -> namelist COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 69


state 53

    (40) functioncall -> prefixexp COLON IDENTIFIER . args
    (41) args -> . LPAREN RPAREN
    (42) args -> . LPAREN explist RPAREN
    (43) args -> . STRING

    LPAREN          shift and go to state 37
    STRING          shift and go to state 38

    args                           shift and go to state 70

state 54

    (30) var -> prefixexp LBRACKET expression . RBRACKET
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    RBRACKET        shift and go to state 71
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 55

    (31) var -> prefixexp DOT IDENTIFIER .

    COLON           reduce using rule 31 (var -> prefixexp DOT IDENTIFIER .)
    LBRACKET        reduce using rule 31 (var -> prefixexp DOT IDENTIFIER .)
    DOT             reduce using rule 31 (var -> prefixexp DOT IDENTIFIER .)
    LPAREN          reduce using rule 31 (var -> prefixexp DOT IDENTIFIER .)
    STRING          reduce using rule 31 (var -> prefixexp DOT IDENTIFIER .)


state 56

    (41) args -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 41 (args -> LPAREN RPAREN .)
    BREAK           reduce using rule 41 (args -> LPAREN RPAREN .)
    DO              reduce using rule 41 (args -> LPAREN RPAREN .)
    WHILE           reduce using rule 41 (args -> LPAREN RPAREN .)
    REPEAT          reduce using rule 41 (args -> LPAREN RPAREN .)
    IF              reduce using rule 41 (args -> LPAREN RPAREN .)
    FOR             reduce using rule 41 (args -> LPAREN RPAREN .)
    LPAREN          reduce using rule 41 (args -> LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 41 (args -> LPAREN RPAREN .)
    INTEGER         reduce using rule 41 (args -> LPAREN RPAREN .)
    FLOAT           reduce using rule 41 (args -> LPAREN RPAREN .)
    $end            reduce using rule 41 (args -> LPAREN RPAREN .)
    COLON           reduce using rule 41 (args -> LPAREN RPAREN .)
    LBRACKET        reduce using rule 41 (args -> LPAREN RPAREN .)
    DOT             reduce using rule 41 (args -> LPAREN RPAREN .)
    STRING          reduce using rule 41 (args -> LPAREN RPAREN .)
    END             reduce using rule 41 (args -> LPAREN RPAREN .)
    UNTIL           reduce using rule 41 (args -> LPAREN RPAREN .)
    ELSEIF          reduce using rule 41 (args -> LPAREN RPAREN .)
    ELSE            reduce using rule 41 (args -> LPAREN RPAREN .)


state 57

    (42) args -> LPAREN explist . RPAREN
    (34) explist -> explist . COMMA expression

    RPAREN          shift and go to state 72
    COMMA           shift and go to state 73


state 58

    (35) explist -> expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    RPAREN          reduce using rule 35 (explist -> expression .)
    COMMA           reduce using rule 35 (explist -> expression .)
    DO              reduce using rule 35 (explist -> expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 59

    (48) term -> term TIMES factor .

    TIMES           reduce using rule 48 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 48 (term -> term TIMES factor .)
    POWER           reduce using rule 48 (term -> term TIMES factor .)
    PLUS            reduce using rule 48 (term -> term TIMES factor .)
    MINUS           reduce using rule 48 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 48 (term -> term TIMES factor .)
    BREAK           reduce using rule 48 (term -> term TIMES factor .)
    DO              reduce using rule 48 (term -> term TIMES factor .)
    WHILE           reduce using rule 48 (term -> term TIMES factor .)
    REPEAT          reduce using rule 48 (term -> term TIMES factor .)
    IF              reduce using rule 48 (term -> term TIMES factor .)
    FOR             reduce using rule 48 (term -> term TIMES factor .)
    LPAREN          reduce using rule 48 (term -> term TIMES factor .)
    IDENTIFIER      reduce using rule 48 (term -> term TIMES factor .)
    INTEGER         reduce using rule 48 (term -> term TIMES factor .)
    FLOAT           reduce using rule 48 (term -> term TIMES factor .)
    $end            reduce using rule 48 (term -> term TIMES factor .)
    END             reduce using rule 48 (term -> term TIMES factor .)
    UNTIL           reduce using rule 48 (term -> term TIMES factor .)
    ELSEIF          reduce using rule 48 (term -> term TIMES factor .)
    ELSE            reduce using rule 48 (term -> term TIMES factor .)
    THEN            reduce using rule 48 (term -> term TIMES factor .)
    RPAREN          reduce using rule 48 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 48 (term -> term TIMES factor .)
    COMMA           reduce using rule 48 (term -> term TIMES factor .)


state 60

    (49) term -> term DIVIDE factor .

    TIMES           reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    POWER           reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 49 (term -> term DIVIDE factor .)
    DO              reduce using rule 49 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 49 (term -> term DIVIDE factor .)
    REPEAT          reduce using rule 49 (term -> term DIVIDE factor .)
    IF              reduce using rule 49 (term -> term DIVIDE factor .)
    FOR             reduce using rule 49 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 49 (term -> term DIVIDE factor .)
    IDENTIFIER      reduce using rule 49 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 49 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 49 (term -> term DIVIDE factor .)
    $end            reduce using rule 49 (term -> term DIVIDE factor .)
    END             reduce using rule 49 (term -> term DIVIDE factor .)
    UNTIL           reduce using rule 49 (term -> term DIVIDE factor .)
    ELSEIF          reduce using rule 49 (term -> term DIVIDE factor .)
    ELSE            reduce using rule 49 (term -> term DIVIDE factor .)
    THEN            reduce using rule 49 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 49 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)


state 61

    (50) term -> term POWER factor .

    TIMES           reduce using rule 50 (term -> term POWER factor .)
    DIVIDE          reduce using rule 50 (term -> term POWER factor .)
    POWER           reduce using rule 50 (term -> term POWER factor .)
    PLUS            reduce using rule 50 (term -> term POWER factor .)
    MINUS           reduce using rule 50 (term -> term POWER factor .)
    SEMICOLON       reduce using rule 50 (term -> term POWER factor .)
    BREAK           reduce using rule 50 (term -> term POWER factor .)
    DO              reduce using rule 50 (term -> term POWER factor .)
    WHILE           reduce using rule 50 (term -> term POWER factor .)
    REPEAT          reduce using rule 50 (term -> term POWER factor .)
    IF              reduce using rule 50 (term -> term POWER factor .)
    FOR             reduce using rule 50 (term -> term POWER factor .)
    LPAREN          reduce using rule 50 (term -> term POWER factor .)
    IDENTIFIER      reduce using rule 50 (term -> term POWER factor .)
    INTEGER         reduce using rule 50 (term -> term POWER factor .)
    FLOAT           reduce using rule 50 (term -> term POWER factor .)
    $end            reduce using rule 50 (term -> term POWER factor .)
    END             reduce using rule 50 (term -> term POWER factor .)
    UNTIL           reduce using rule 50 (term -> term POWER factor .)
    ELSEIF          reduce using rule 50 (term -> term POWER factor .)
    ELSE            reduce using rule 50 (term -> term POWER factor .)
    THEN            reduce using rule 50 (term -> term POWER factor .)
    RPAREN          reduce using rule 50 (term -> term POWER factor .)
    RBRACKET        reduce using rule 50 (term -> term POWER factor .)
    COMMA           reduce using rule 50 (term -> term POWER factor .)


state 62

    (38) prefixexp -> LPAREN expression RPAREN .
    (55) factor -> LPAREN expression RPAREN .

  ! reduce/reduce conflict for LPAREN resolved using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    COLON           reduce using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    DOT             reduce using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    STRING          reduce using rule 38 (prefixexp -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    POWER           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ELSEIF          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 55 (factor -> LPAREN expression RPAREN .)

  ! LPAREN          [ reduce using rule 55 (factor -> LPAREN expression RPAREN .) ]


state 63

    (11) stat -> WHILE expression DO block . END

    END             shift and go to state 74


state 64

    (55) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    POWER           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    DO              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ELSEIF          reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 55 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 55 (factor -> LPAREN expression RPAREN .)


state 65

    (12) stat -> REPEAT block UNTIL expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    BREAK           reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    DO              reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    WHILE           reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    REPEAT          reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    IF              reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    FOR             reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    LPAREN          reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    IDENTIFIER      reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    INTEGER         reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    FLOAT           reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    $end            reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    END             reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    UNTIL           reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    ELSEIF          reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    ELSE            reduce using rule 12 (stat -> REPEAT block UNTIL expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 66

    (13) stat -> IF expression THEN block . elseif_blocks else_block END
    (14) elseif_blocks -> . ELSEIF expression THEN block
    (15) elseif_blocks -> . elseif_blocks ELSEIF expression THEN block
    (16) elseif_blocks -> . empty
    (21) empty -> .

  ! shift/reduce conflict for ELSEIF resolved as shift
    ELSEIF          shift and go to state 76
    ELSE            reduce using rule 21 (empty -> .)
    END             reduce using rule 21 (empty -> .)

  ! ELSEIF          [ reduce using rule 21 (empty -> .) ]

    elseif_blocks                  shift and go to state 75
    empty                          shift and go to state 77

state 67

    (19) stat -> FOR IDENTIFIER ASSIGN expression . COMMA expression DO block END
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    COMMA           shift and go to state 78
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 68

    (20) stat -> FOR namelist IN explist . DO block END
    (34) explist -> explist . COMMA expression

    DO              shift and go to state 79
    COMMA           shift and go to state 73


state 69

    (32) namelist -> namelist COMMA IDENTIFIER .

    IN              reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)
    COMMA           reduce using rule 32 (namelist -> namelist COMMA IDENTIFIER .)


state 70

    (40) functioncall -> prefixexp COLON IDENTIFIER args .

    SEMICOLON       reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    BREAK           reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    DO              reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    WHILE           reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    REPEAT          reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    IF              reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    FOR             reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LPAREN          reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    IDENTIFIER      reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    INTEGER         reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    FLOAT           reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    $end            reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    COLON           reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    LBRACKET        reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    DOT             reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    STRING          reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    END             reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    UNTIL           reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    ELSEIF          reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)
    ELSE            reduce using rule 40 (functioncall -> prefixexp COLON IDENTIFIER args .)


state 71

    (30) var -> prefixexp LBRACKET expression RBRACKET .

    COLON           reduce using rule 30 (var -> prefixexp LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 30 (var -> prefixexp LBRACKET expression RBRACKET .)
    DOT             reduce using rule 30 (var -> prefixexp LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 30 (var -> prefixexp LBRACKET expression RBRACKET .)
    STRING          reduce using rule 30 (var -> prefixexp LBRACKET expression RBRACKET .)


state 72

    (42) args -> LPAREN explist RPAREN .

    SEMICOLON       reduce using rule 42 (args -> LPAREN explist RPAREN .)
    BREAK           reduce using rule 42 (args -> LPAREN explist RPAREN .)
    DO              reduce using rule 42 (args -> LPAREN explist RPAREN .)
    WHILE           reduce using rule 42 (args -> LPAREN explist RPAREN .)
    REPEAT          reduce using rule 42 (args -> LPAREN explist RPAREN .)
    IF              reduce using rule 42 (args -> LPAREN explist RPAREN .)
    FOR             reduce using rule 42 (args -> LPAREN explist RPAREN .)
    LPAREN          reduce using rule 42 (args -> LPAREN explist RPAREN .)
    IDENTIFIER      reduce using rule 42 (args -> LPAREN explist RPAREN .)
    INTEGER         reduce using rule 42 (args -> LPAREN explist RPAREN .)
    FLOAT           reduce using rule 42 (args -> LPAREN explist RPAREN .)
    $end            reduce using rule 42 (args -> LPAREN explist RPAREN .)
    COLON           reduce using rule 42 (args -> LPAREN explist RPAREN .)
    LBRACKET        reduce using rule 42 (args -> LPAREN explist RPAREN .)
    DOT             reduce using rule 42 (args -> LPAREN explist RPAREN .)
    STRING          reduce using rule 42 (args -> LPAREN explist RPAREN .)
    END             reduce using rule 42 (args -> LPAREN explist RPAREN .)
    UNTIL           reduce using rule 42 (args -> LPAREN explist RPAREN .)
    ELSEIF          reduce using rule 42 (args -> LPAREN explist RPAREN .)
    ELSE            reduce using rule 42 (args -> LPAREN explist RPAREN .)


state 73

    (34) explist -> explist COMMA . expression
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 80
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 74

    (11) stat -> WHILE expression DO block END .

    SEMICOLON       reduce using rule 11 (stat -> WHILE expression DO block END .)
    BREAK           reduce using rule 11 (stat -> WHILE expression DO block END .)
    DO              reduce using rule 11 (stat -> WHILE expression DO block END .)
    WHILE           reduce using rule 11 (stat -> WHILE expression DO block END .)
    REPEAT          reduce using rule 11 (stat -> WHILE expression DO block END .)
    IF              reduce using rule 11 (stat -> WHILE expression DO block END .)
    FOR             reduce using rule 11 (stat -> WHILE expression DO block END .)
    LPAREN          reduce using rule 11 (stat -> WHILE expression DO block END .)
    IDENTIFIER      reduce using rule 11 (stat -> WHILE expression DO block END .)
    INTEGER         reduce using rule 11 (stat -> WHILE expression DO block END .)
    FLOAT           reduce using rule 11 (stat -> WHILE expression DO block END .)
    $end            reduce using rule 11 (stat -> WHILE expression DO block END .)
    END             reduce using rule 11 (stat -> WHILE expression DO block END .)
    UNTIL           reduce using rule 11 (stat -> WHILE expression DO block END .)
    ELSEIF          reduce using rule 11 (stat -> WHILE expression DO block END .)
    ELSE            reduce using rule 11 (stat -> WHILE expression DO block END .)


state 75

    (13) stat -> IF expression THEN block elseif_blocks . else_block END
    (15) elseif_blocks -> elseif_blocks . ELSEIF expression THEN block
    (17) else_block -> . ELSE block
    (18) else_block -> . empty
    (21) empty -> .

    ELSEIF          shift and go to state 82
    ELSE            shift and go to state 83
    END             reduce using rule 21 (empty -> .)

    else_block                     shift and go to state 81
    empty                          shift and go to state 84

state 76

    (14) elseif_blocks -> ELSEIF . expression THEN block
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 85
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 77

    (16) elseif_blocks -> empty .

    ELSEIF          reduce using rule 16 (elseif_blocks -> empty .)
    ELSE            reduce using rule 16 (elseif_blocks -> empty .)
    END             reduce using rule 16 (elseif_blocks -> empty .)


state 78

    (19) stat -> FOR IDENTIFIER ASSIGN expression COMMA . expression DO block END
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 86
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 79

    (20) stat -> FOR namelist IN explist DO . block END
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    block                          shift and go to state 87
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    expression                     shift and go to state 9
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 80

    (34) explist -> explist COMMA expression .
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    RPAREN          reduce using rule 34 (explist -> explist COMMA expression .)
    COMMA           reduce using rule 34 (explist -> explist COMMA expression .)
    DO              reduce using rule 34 (explist -> explist COMMA expression .)
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 81

    (13) stat -> IF expression THEN block elseif_blocks else_block . END

    END             shift and go to state 88


state 82

    (15) elseif_blocks -> elseif_blocks ELSEIF . expression THEN block
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22
    LPAREN          shift and go to state 28

    expression                     shift and go to state 89
    term                           shift and go to state 17
    factor                         shift and go to state 20

state 83

    (17) else_block -> ELSE . block
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    block                          shift and go to state 90
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    expression                     shift and go to state 9
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 84

    (18) else_block -> empty .

    END             reduce using rule 18 (else_block -> empty .)


state 85

    (14) elseif_blocks -> ELSEIF expression . THEN block
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    THEN            shift and go to state 91
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 86

    (19) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression . DO block END
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    DO              shift and go to state 92
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 87

    (20) stat -> FOR namelist IN explist DO block . END

    END             shift and go to state 93


state 88

    (13) stat -> IF expression THEN block elseif_blocks else_block END .

    SEMICOLON       reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    BREAK           reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    DO              reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    WHILE           reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    REPEAT          reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    IF              reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    FOR             reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    LPAREN          reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    IDENTIFIER      reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    INTEGER         reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    FLOAT           reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    $end            reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    END             reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    UNTIL           reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    ELSEIF          reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)
    ELSE            reduce using rule 13 (stat -> IF expression THEN block elseif_blocks else_block END .)


state 89

    (15) elseif_blocks -> elseif_blocks ELSEIF expression . THEN block
    (46) expression -> expression . PLUS term
    (47) expression -> expression . MINUS term

    THEN            shift and go to state 94
    PLUS            shift and go to state 24
    MINUS           shift and go to state 25


state 90

    (17) else_block -> ELSE block .

    END             reduce using rule 17 (else_block -> ELSE block .)


state 91

    (14) elseif_blocks -> ELSEIF expression THEN . block
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    expression                     shift and go to state 9
    block                          shift and go to state 95
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 92

    (19) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO . block END
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    expression                     shift and go to state 9
    block                          shift and go to state 96
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 93

    (20) stat -> FOR namelist IN explist DO block END .

    SEMICOLON       reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    BREAK           reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    DO              reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    WHILE           reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    REPEAT          reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    IF              reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    FOR             reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    LPAREN          reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    IDENTIFIER      reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    INTEGER         reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    FLOAT           reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    $end            reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    END             reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    UNTIL           reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    ELSEIF          reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)
    ELSE            reduce using rule 20 (stat -> FOR namelist IN explist DO block END .)


state 94

    (15) elseif_blocks -> elseif_blocks ELSEIF expression THEN . block
    (3) block -> . stat_list
    (4) stat_list -> . stat_list stat
    (5) stat_list -> . stat
    (6) stat -> . SEMICOLON
    (7) stat -> . functioncall
    (8) stat -> . BREAK
    (9) stat -> . expression
    (10) stat -> . DO block END
    (11) stat -> . WHILE expression DO block END
    (12) stat -> . REPEAT block UNTIL expression
    (13) stat -> . IF expression THEN block elseif_blocks else_block END
    (19) stat -> . FOR IDENTIFIER ASSIGN expression COMMA expression DO block END
    (20) stat -> . FOR namelist IN explist DO block END
    (39) functioncall -> . prefixexp args
    (40) functioncall -> . prefixexp COLON IDENTIFIER args
    (46) expression -> . expression PLUS term
    (47) expression -> . expression MINUS term
    (51) expression -> . term
    (36) prefixexp -> . var
    (37) prefixexp -> . functioncall
    (38) prefixexp -> . LPAREN expression RPAREN
    (48) term -> . term TIMES factor
    (49) term -> . term DIVIDE factor
    (50) term -> . term POWER factor
    (52) term -> . factor
    (29) var -> . IDENTIFIER
    (30) var -> . prefixexp LBRACKET expression RBRACKET
    (31) var -> . prefixexp DOT IDENTIFIER
    (53) factor -> . INTEGER
    (54) factor -> . FLOAT
    (55) factor -> . LPAREN expression RPAREN

    SEMICOLON       shift and go to state 6
    BREAK           shift and go to state 8
    DO              shift and go to state 10
    WHILE           shift and go to state 11
    REPEAT          shift and go to state 12
    IF              shift and go to state 13
    FOR             shift and go to state 14
    LPAREN          shift and go to state 19
    IDENTIFIER      shift and go to state 15
    INTEGER         shift and go to state 21
    FLOAT           shift and go to state 22

    expression                     shift and go to state 9
    block                          shift and go to state 97
    stat_list                      shift and go to state 4
    stat                           shift and go to state 5
    functioncall                   shift and go to state 7
    prefixexp                      shift and go to state 16
    term                           shift and go to state 17
    var                            shift and go to state 18
    factor                         shift and go to state 20

state 95

    (14) elseif_blocks -> ELSEIF expression THEN block .

    ELSEIF          reduce using rule 14 (elseif_blocks -> ELSEIF expression THEN block .)
    ELSE            reduce using rule 14 (elseif_blocks -> ELSEIF expression THEN block .)
    END             reduce using rule 14 (elseif_blocks -> ELSEIF expression THEN block .)


state 96

    (19) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block . END

    END             shift and go to state 98


state 97

    (15) elseif_blocks -> elseif_blocks ELSEIF expression THEN block .

    ELSEIF          reduce using rule 15 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)
    ELSE            reduce using rule 15 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)
    END             reduce using rule 15 (elseif_blocks -> elseif_blocks ELSEIF expression THEN block .)


state 98

    (19) stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .

    SEMICOLON       reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    BREAK           reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    DO              reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    WHILE           reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    REPEAT          reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    IF              reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    FOR             reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    LPAREN          reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    IDENTIFIER      reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    INTEGER         reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    FLOAT           reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    $end            reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    END             reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    UNTIL           reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    ELSEIF          reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)
    ELSE            reduce using rule 19 (stat -> FOR IDENTIFIER ASSIGN expression COMMA expression DO block END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSEIF in state 66 resolved as shift
WARNING: reduce/reduce conflict in state 7 resolved using rule (stat -> functioncall)
WARNING: rejected rule (prefixexp -> functioncall) in state 7
WARNING: reduce/reduce conflict in state 62 resolved using rule (prefixexp -> LPAREN expression RPAREN)
WARNING: rejected rule (factor -> LPAREN expression RPAREN) in state 62
